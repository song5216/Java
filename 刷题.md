# 刷题0.0

## 1-10

#### 1 使用链表实现归并排序

```
链表排序（归并 nlog（n））
描述
在O(n log n)的时间内使用常数级空间复杂度对链表进行排序。
示例1
输入：
{30,20,40}
复制
返回值：
{20,30,40}

import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
      public ListNode sortList (ListNode head) {
        
        // write code here
        sort(head);
        return head;
        
    }
    
    public void sort(ListNode head){
        if(head==null||head.next==null){
            return;
        }
        //分
        ListNode mid = getmid(head);
        ListNode head2 = mid.next;
        mid.next=null;
        
        sort(head);
        sort(head2);
        //归
        merge(head,head2);
    }
    public void merge(ListNode head1,ListNode head2){
        ListNode temp1 = head1;//定义两个指针结点
        ListNode temp2 = head2;
        ListNode node = new ListNode(0);//任意设置一个临时结点
        while(temp2!=null){
            
            ListNode temp = temp2.next;//保存temp2的下一个结点
            
            while(temp1!=null){
                if(temp2.val<temp1.val){
                    int temp_val = temp1.val;//这里这么做的目的是仅仅改变val不改变 首结点的地址，因为后续需要继续使用首结点进行计算
                    temp1.val= temp2.val;
                    temp2.val = temp_val;
                        
                    ListNode temp3 = temp1.next;//结点插入
                    temp1.next=temp2;
                    temp2.next=temp3;
                    break;
                }else{
                    if(temp1.next==null){//若到达最后一个元素
                        temp1.next=temp2;
                        temp1.next.next=null;//特别注意断链，此处仅仅排了一个temp2,不断链的化temp2的next也会排入其中
                        break;
                    }
                     temp1=temp1.next;
                }
            }
            
            if(temp==null){//如果temp2/head2 中的元素全部插入则退出
                break;
            }
            temp1=head1; //更新temp1指针用于后续比较
            temp2 = temp;//取head2的下一个结点
        }
    }
    
    
    
    public ListNode getmid(ListNode head){
        ListNode temp = head;
        int count = 1;
        while(temp.next!=null){
            temp=temp.next;
            count++;
        }
        if(count==2){
            return head;
        }
        int mid = count/2+1;
        temp = head;
        
        while(count!=mid){
            temp=temp.next;
            count--;
        }
        return temp;  
    }
}
////归并排序
//改进注意合并时 排序使用两个指针 ，避免两次循环的排序方法

import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
      public ListNode sortList (ListNode head) {
         if(head==null||head.next==null){
            return head;
        }
        //分
        ListNode mid = getmid(head);
        ListNode head2 = mid.next;
        mid.next=null;

        head=sortList(head);
        head2=sortList(head2);
        //归
        head = merge(head,head2);
        return head;
    }

    public ListNode merge(ListNode head1,ListNode head2){
        //定义两个指针结点
        ListNode temp2 = head2;
        ListNode head = new ListNode(0);//任意设置一个临时首结点
        head.next=head1;//定义一个临时首结点
        ListNode temp1 = head;

        while(temp1.next!=null&&temp2!=null){//边界条件
            //指针移动比较两指针结点处的val值

            //如果temp1.next<temp2的val值，将temp2的val赋给node，并插入head1中， 使用temp1.next的原因是便于
            //找到比较结点的上一个结点，方便插入
            if(temp1.next.val>temp2.val){
                //temp2结点复制到node，temp2指针向后移动一位,node断链
                ListNode node = temp2;
                temp2=temp2.next;
                node.next=null;

                //将node插入到head1中,更新temp1
                node.next=temp1.next;
                temp1.next=node;
                temp1=node;
            }else{//如果>=则，temp1向后移动

                temp1=temp1.next;
            }
        }
        //若temp1.next==null，则将temp2的后续元素全部插入到temp1之后
        if(temp1.next==null){
            temp1.next=temp2;
        }
        return head.next;
    }



    public ListNode getmid(ListNode head){
        ListNode temp = head;
        int count = 1;
        while(temp.next!=null){
            temp=temp.next;
            count++;
        }
        if(count==2){
            return head;
        }
        int mid = count/2+1;
        temp = head;

        while(count!=mid){
            temp=temp.next;
            count--;
        }
        return temp;  
    }
}
```

#### 2 二维数组查找

**描述**

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

[

 [1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15]

]

给定 target = 7，返回 true。

给定 target = 3，返回 false。



/取右上或者左下元素 //以左下为例，左下：所在列最大，所在行最小 //target 大于他行方向移动 小于它 列方向移动

```
public class Solution {
    public boolean Find(int target, int [][] array) {
        //横向遍历
        int c = array.length;
        int r = array[0].length;
        int i= c-1;
        int j = 0;
        while((0<=i)&&(i<=c-1)&(0<=j)&(j<=r-1)){
            //if 等于 return true
            if(target==array[i][j]){
                return true;
            }
           //if target 小于 [i,j](左下：所在列最大，所在行最小)，需要i++，列方向上移
            if(target<array[i][j]){
                i--;
                continue;
            }
            if(target>array[i][j]){
                j++;
                continue;
            }
        }
        return false;

    }

}
```

#### 3 字符串替换

描述

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @return string字符串
     */
    public String replaceSpace (String s) {
        // write code here
        char[] S=s.toCharArray();
        String T="";

        for(int i = 0 ;i<s.length();i++){
            if(S[i]==' '){
                T=T+"%20";
            }else{
                T=T+S[i];
            }
        }
        return T;

        }
    }
```

#### 4**从尾到头打印链表**

描述输入一个链表的头结点，按链表从尾到头的顺序返回每个结点的值（用数组返回）。

输入：

```
{1,2,3}
```

返回值：

```
[3,2,1]
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    
        ArrayList<Integer> a = new ArrayList<>(0);
         while(listNode!=null){
             a.add(listNode.val);
             listNode=listNode.next;
         }

         ArrayList<Integer> b = new ArrayList<>(a.size());
         for(int i=0; i<a.size();i++){
             b.add(a.get(a.size()-1-i));
         }
        
         return b;
    }
}

//使用栈
import java.util.Stack;
import java.util.ArrayList;
public class Solution {
     public ArrayList printListFromTailToHead(ListNode listNode) {
        ArrayList list = new ArrayList();
        Stack stack = new Stack();
        while (listNode != null) {
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while (!stack.empty()) {
            list.add(stack.pop());
        }
        return list;
    }
}
```

#### 5.用两个堆表示栈

**描述**

用两个栈来实现一个队列，分别完成在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。

**示例:**

输入:

["PSH1","PSH2","POP","POP"]

返回:

1,2

**解析:**

"PSH1":代表将1插入队列尾部

"PSH2":代表将2插入队列尾部

"POP“:代表删除一个元素，先进先出=>返回1

"POP“:代表删除一个元素，先进先出=>返回2

```
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        
        stack1.push(node);
        
    }
    
    public int pop() {
        if((stack2.size()!=0)){//重点如果 stack2 不为空，不可将stack1的数据push到stack2中；否则后来的元素会在先来的元素之上
            return stack2.pop();
        }else{
            while(stack1.size()!=0){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
            
        }
    }
}
```

#### 6.斐波那契数列

描述

大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。

n≤39

示例1

输入：

```
4
```

返回值：

```
3
public class Solution {
    
    
    public int Fibonacci(int n) {
     
        int x_1=0;
        int x_2=1;

        int x=0;
        if(n==0){
            return x_1;
        }
        for(int i=0; i<n-1;i++){
            x= x_2;
            x_2= x_1+x_2;
            x_1=x;
            
        }
        return x_2;

    }
    
}
```

#### 7.二进制中1的个数

**描述**

输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

**示例1**

输入：

```
10 //1010
```

返回值：

```
2
public class Solution {
    public int NumberOf1(int n) {
        int flag= 0 ;
        while(n!=0){
            n=n&(n-1);
            flag++;
        }
        return flag;

    }
}
```

#### 8 数值的整数次方

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。

示例1

输入：

```
2.00000,3
```

返回值：

```
8.00000
public class Solution {
    public double Power(double base, int exponent) {
        double base_final=base;
        if((exponent>0)){
            
            while(exponent!=1){
                base_final = base_final*base;
                exponent--;
            }
            return base_final;
        }
        if((exponent<0)){
            while(exponent!=-1){
                base_final = base_final*base;
                exponent++;
            }
            return 1/base_final;
        }
        return 1.0;

  }
  
}

方法二：递归法（快速幂）
class Solution {
public:
    double q_power(double b, int n) {
        if (n == 0) return 1.0;
        double ret = q_power(b, n/2);
        if (n&1) { // 奇数
            return ret * ret * b;
        }
        else {
            return ret * ret;
        }
    }
    double Power(double b, int n) {
        if (n < 0) {
            b = 1 / b;
            n = -n;
        }
        return q_power(b, n);
    }
};
时间复杂度：O(logn)，每次规模减少一半
空间复杂度：O(logn)，递归栈，因为要记住logn个变量

方法三：非递归的快速幂


class Solution {
public:
 
    double Power(double b, int n) {
        if (n < 0) {
            b = 1 / b;
            n = -n;
        }
        double x = b; // 记录x^0, x^1, x^2 ...
        double ret = 1.0;
        while (n) {
            if (n&1) {
                ret *= x; // 二进制位数是1的，乘进答案。
            }
            x *= x;
            n >>= 1;
        }
        return ret;
    }
};
上述方法相当于遍历n的二进制位，是1就乘进结果
时间复杂度：O(logn)，因为n的二进制位个数为logn
空间复杂度：O(1)
```

#### 9**调整数组顺序使奇数位于偶数前面**

描述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

示例1

输入：

```
[1,2,3,4]
```

返回值：

```
[1,3,2,4]
```

复制

示例2

输入：

```
[2,4,6,5,7]
```

返回值：

```
[5,7,2,4,6]
```



```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] reOrderArray (int[] array) {
        ListNode list1 =new ListNode(0);
        ListNode list2 =new ListNode(0);
        ListNode head = list1;
       
        ListNode head2 = list2;
        for(int i=0;i<array.length;i++){
            if(array[i]%2!=0){
                ListNode list_next =new ListNode(array[i]);
                list1.next=list_next;
                list1=list_next;
            }else{
                ListNode list_per =new ListNode(array[i]);
                list2.next=list_per;
                list2=list_per;
            }
        }
        list1.next=head2.next;
        head = head.next;
        int[] arr = new int[array.length];
        for(int i=0;i<array.length;i++){
           
            arr[i]=head.val;
            head=head.next;
        }
        return arr;
        // write code here
    }
}



import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] reOrderArray (int[] array) {
       
        //双指针，头尾指针
        int[] nums = new int[array.length];
        int head = 0;
        int tail = array.length-1;
        int index_head = head;
        int index_tail = tail;
        while(head < array.length && tail >= 0){
            if(array[head] % 2 == 1){
                //奇数，放前面
                nums[index_head] = array[head];
                index_head++;
            }
            head++;
            if(array[tail] % 2 == 0){
                //从后到前，如果为偶数，则从后开始填
                nums[index_tail] = array[tail];
                index_tail--;
            }
            tail--;
        }
        return nums;
    }
}
```

#### 10 链表反转

输入一个链表，反转链表后，输出新链表的表头。

示例1

输入：

```
{1,2,3}
```

返回值：

```
{3,2,1}


public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode Head =head;
        while(Head.next!=null){
            Head=Head.next;//直接找到首结点并记录
        }
   
        reverse(head);
        return Head;
    }
    public ListNode reverse(ListNode cur){       
        if(cur.next==null){
            return cur;
           
        }
        
        ListNode per = reverse(cur.next);
        per.next = cur;
        cur.next=null;
        return cur;
    }
}


public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }   
        ListNode Head =new ListNode(0);//提前定义一个额外的首结点
        reverse(head,Head);
        return Head.next;
    }
    public ListNode reverse(ListNode cur,ListNode Head){       
        if(cur.next==null){
            Head.next=cur;
            return cur;
        }
        
        ListNode per = reverse(cur.next,Head);
        per.next = cur;
        cur.next=null;
        return cur;
    }
}
```

## 11-20

#### 11 合并两个有序链表

**描述**

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

**示例**

输入：

```
{1,3,5},{2,4,6}
```

返回值：

```
{1,2,3,4,5,6}
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        
      
        //双指针
        ListNode temp1 = list1;
        ListNode temp2 = list2;
        
        ListNode Head = new ListNode(0);
        ListNode head = Head;
        
        while(temp1!=null&&temp2!=null){
            if(temp1.val<temp2.val){
            head.next = new ListNode(temp1.val);
            head = head.next;
            temp1 = temp1.next;
            }else{
            head.next = new ListNode(temp2.val);
            head = head.next;
            temp2 = temp2.next;
             }
        }
        
        if(temp1==null){
            head.next = temp2;
        }
        if(temp2==null){
            head.next = temp1;
        }
        
        return Head.next;
        
        
    }
}
```

#### 12 顺时针打印矩阵

描述

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：

```
[[1,2,3,4],
[5,6,7,8],
[9,10,11,12],
[13,14,15,16]]
```

则依次打印出数字

```
[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]
import java.util.ArrayList;
public class Solution {
      public static ArrayList<Integer> printMatrix(int [][] matrix) {
                if(matrix.length==0|matrix==null){
                        return null;
                }
                ArrayList array = new ArrayList();
                sort(matrix,0,array);

                return array;

        }

        public static void sort(int [][] matrix,int k,ArrayList array){
                if( (k>((matrix.length-1)/2)) ||(k>((matrix[0].length-1)/2))){
                        return;
                }
            
            if(!(k<matrix[0].length-k)){
                        return;
                }
                for(int i= k; i<matrix[0].length-k; i++){
                        
                        array.add(matrix[k][i]);
                }
               
               if(!(k+1<matrix.length-k)){
                   return;
               }
                for(int i= k+1; i<matrix.length-k; i++){
                        array.add(matrix[i][matrix[0].length-k-1]);
                }
               if(!(matrix[0].length-k-2>=k)){
                   return;
               }
                for(int i= matrix[0].length-k-2; i>=k; i--){
                        array.add(matrix[matrix.length-k-1][i]);
                }
               if(!(matrix.length-k-2>k)){
                   return;
               }
                for(int i= matrix.length-k-2; i>k; i--){
                        array.add(matrix[i][k]);
                }
                sort(matrix,k+1,array);
        }}

public static ArrayList<Integer> printMatrix(int [][] matrix) {
                if(matrix.length==0|matrix==null){
                        return null;
                }
                int x0 =0;
                int y0 =0;
                int x1 = matrix.length-1;
                int y1 = matrix[0].length-1;


                ArrayList array = new ArrayList();
                sort( matrix,x0,y0,x1,y1,array);

                return array;

        }

        public static void sort(int [][] matrix,int x0,int y0,int x1,int y1, ArrayList array){

                if(x0>x1|y0>y1){
                        return;
                }

                for(int i= y0; i<=y1; i++){

                        array.add(matrix[x0][i]);
                }
                for(int i= x0+1; i<=x1; i++){
                        array.add(matrix[i][y1]);
                }
                if(x0==x1){//如果只有一行不执行第三次遍历
                        return;
                }
                for(int i= y1-1; i>=y0; i--){
                        array.add(matrix[x1][i]);
                }
                if(y0==y1){//如果只有一列不执行第四次遍历
                        return;
                }
                for(int i= x1-1; i>x0; i--){
                        array.add(matrix[i][y0]);
                }
                sort(matrix,x0+1,y0+1,x1-1,y1-1,array);

        }
}

```

#### 13 **链表中倒数最后k个结点**

描述

输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾结点的全部结点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

示例1

输入：

```
{1,2,3,4,5},1 
```

返回值：

```
{5}
import java.util.*;
/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pHead ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode FindKthToTail (ListNode pHead, int k) {
        // write code here
        ListNode temp = pHead;
        int count=0;
        while(temp!=null){
            count++;
            temp = temp.next;
        }   
        int i = count-k;
        if(i<0){
            return null;
        }
        while(i>0){
            pHead = pHead.next;
            i--;
        }
        return pHead;   
    }
}


//双指针这题要求链表的倒数第k个结点，最简单的方式就是使用两个指针，第一个指针先移动k步，然后第二个指针再从头开始，这个时候这两个指针同时移动，当第一个指针到链表的末尾的时候，返回第二个指针即可。注意，如果第一个指针还没走k步的时候链表就为空了，我们直接返回null即可。

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pHead ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode FindKthToTail (ListNode pHead, int k) {
        // write code here
        ListNode f = pHead;
        ListNode s = pHead;
        for(int i = 0; i<k; i++){
            if(f==null){
                return null;//这个判断要在前面
            }
            f=f.next;
            
        }
        
        while(f!=null){
            f=f.next;
            s=s.next;
        }
        return s;
        

    }
}
```

#### 14 **包含min函数的栈**

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)

push(value):将value压入栈中

pop():弹出栈顶元素

top():获取栈顶元素

min():获取栈中最小元素

```

//利用链表按照顺序存储元素
import java.util.Stack;
import java.util.LinkedList;
public class Solution {
    private  Stack<Integer> stack = new Stack<Integer>();
    private LinkedList<Integer> Listsort = new LinkedList<Integer>();
  
    public void push(int node) {
        if(stack.size()==0){
            Listsort.add(node);
        }else{
            if(node<Listsort.getFirst().intValue()){
                Listsort.addFirst(node);
            }
        }
        stack.push(node);
    }
    
    public void pop() {
        int top = stack.pop();
        Listsort.remove(top);
        
    }
    
    public int top() {
        int top = stack.pop();
        stack.push(top);
        return top;
    }
    
    public int min() {
        return Listsort.getFirst();
    }
}

//辅助栈，对于辅助栈 ，最小值在栈顶，push时如果压入的值不小于栈顶的值，则重复压入栈顶的值
import java.util.Stack;
import java.util.ArrayList;
public class Solution {
    private  Stack<Integer> stack = new Stack<Integer>();
    private  Stack<Integer> minstack = new Stack<Integer>();
   
  
    public void push(int node) {
        if(stack.size()==0){
           minstack.push(node);
        }else{
            if(node< minstack.lastElement()){
                minstack.push(node);
            }else{
                minstack.push(minstack.lastElement());
            }
        }
        stack.push(node);
    }
    
    public void pop() {
        stack.pop();
        minstack.pop();
        
    }
    
    public int top() {
        
        return stack.lastElement();
    }
    
    public int min() {
        return minstack.lastElement();
    }
}
```

#### 15 **栈的压入、弹出序列**

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。

假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

示例1

输入：

```
[1,2,3,4,5],[4,3,5,1,2]
```

返回值：

```
false
import java.util.ArrayList;

public class Solution {
    public static boolean IsPopOrder(int [] pushA,int [] popA) {
                ArrayList<Integer> a = new ArrayList();
                int i=0;
                int j=0;
                while(i<pushA.length){
                        if(pushA[i]!=popA[j]){
                                a.add(pushA[i]);
                                i++;
                        }else{
                                i++;
                                j++;
                                while(a.size()>0&&popA[j]==a.get(a.size()-1)){
                                        a.remove(a.size()-1);
                                        j++;
                                }
                        }
                }

                if(a.size()>0){
                        return false;
                }
                return true;
        }
}
```

#### 16复杂链表的复制

输入一个复杂链表（每个结点中有结点值，以及两个指针，一个指向下一个结点，另一个特殊指针random指向一个随机结点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的结点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。

```
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead) {
        if(pHead==null){
          
            return null;
        }
        RandomListNode temp = pHead;
        RandomListNode head =  new RandomListNode(temp.label);;
        RandomListNode temp1 = head;
        
//实指针拷贝
        while(temp.next!=null){
            temp1.next = new RandomListNode(temp.next.label);
            temp1 = temp1.next;
            temp = temp.next;
        }
        temp = pHead;
        temp1 = head;
        while(temp!= null){
            copy(pHead,head,temp,temp1);
            temp= temp.next;
            temp1= temp1.next;
        }
        
        return head;

    }
     public void copy(RandomListNode pHead,RandomListNode head,RandomListNode Node1,RandomListNode Node2){
         if(Node1.random==null){
             return;
         }
         int N=0;
         RandomListNode temp = pHead;
         while(Node1.random!=temp){
             temp = temp.next;
             N++;
         }
         temp = head;
         for(int i =0;i<N;i++){
             temp = temp.next;
         }
         Node2.random = temp;
     }
    
    
    
}

import java.util.*;
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead) {
        
        if(pHead==null){
          
            return null;
        }
        ArrayList parry =new ArrayList();
        ArrayList arry =new ArrayList();
        RandomListNode temp = pHead;
        RandomListNode head =  new RandomListNode(temp.label);;
        RandomListNode temp1 = head;
        
//实指针拷贝
        parry.add(temp);
        arry.add(temp1);
        while(temp.next!=null){
            temp1.next = new RandomListNode(temp.next.label);
            temp1 = temp1.next;
            temp = temp.next;
            parry.add(temp);
            arry.add(temp1);
        }
        temp = pHead;
        temp1 = head;
        while(temp!= null){
            copy(parry,arry,temp,temp1);
            temp= temp.next;
            temp1= temp1.next;
        }
        
        return head;

    }
     public void copy(ArrayList parry, ArrayList arry, RandomListNode Node1,RandomListNode Node2){
         if(Node1.random==null){
             return;
         }
         int index =parry.indexOf(Node1.random);
         Node2.random = (RandomListNode)arry.get(index);
     }
 
}
```

#### 17  最小的K个数

描述

给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

- 0 <= k <= input.length <= 10000
- 0 <= input[i] <= 10000

```
import java.util.ArrayList;

public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        int [] a = new int[input.length];
        sort(input,a);
        ArrayList array = new ArrayList();
        if(k>input.length){
            k=input.length;
        }
        for(int i=0; i<k; i++){
            array.add(a[i]);
        }
        return array;
    }
    
    public void sort(int [] input,int [] a){
        int last = input.length-1;
        int first = 0;
        gsort(first,last,input,a);
        
    }
    
    public void gsort(int first,int last,int [] input,int[] a){
      
        if(first>=last){
            return;
        }
        int mid = (first+last)/2;
   
        gsort(first,mid,input,a);
        gsort(mid+1,last,input,a);
        int pointer1 = first;
        int pointer2 = mid+1;
        int pointer = first;
        while(pointer1<=mid&&pointer2<=last){
            if(input[pointer1]>input[pointer2]){
                a[pointer]=input[pointer2];
                pointer2++;
            }else{
                a[pointer]=input[pointer1];
                pointer1++;
            }
            pointer++;
        }

        while(pointer1<=mid){
            a[pointer++]=input[pointer1++];
        }
        while(pointer2<=last){
            a[pointer++]=input[pointer2++];
        }
         for(int i = first;i<= last ;i++){
                        input[i]=a[i];
                }
    }
}
```

#### 18 层序遍历二叉树

从上往下打印出二叉树的每个结点，同层结点从左至右打印。

示例1

输入：

```
{5,4,#,3,#,2,#,1}
```

返回值：

```
[5,4,3,2,1]
import java.util.*;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        LinkedList<TreeNode> array = new LinkedList();
         ArrayList<Integer> arr = new ArrayList();
        if(root==null){
            return arr;
        }
        array.add(root);
        while(array.size()!=0){
            TreeNode Nodd = array.poll();
            arr.add(Nodd.val);
            if(Nodd.left!=null){
                array.add(Nodd.left);
            }
            if(Nodd.right!=null){
                array.add(Nodd.right);
            }
        }
        return arr;
    }
    
    
}
```

**注意：**

**LinkedList的方法中add 是在链表的尾部加元素；pop是在首部取元素；**push是在首部压元素



#### 20 重建二叉树

给定某二叉树的前序遍历和中序遍历，请重建出该二叉树并返回它的头结点。

例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}。

```
import java.util.*;
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] vin) {
        if(pre.length==0){
            return null;
        }
        TreeNode head = new TreeNode(pre[0]);
        reConstruct(head,pre,vin);
        return head;
    }
    
    public void reConstruct(TreeNode node, int [] pre,int [] vin){
        if(pre.length==0){
            return;
        }
        //根据前序第一个元素first找到根结点
        int vinIndexOfroot =0;
         for(int i=0; i<pre.length; i++){
            if(vin[i]==pre[0]){
                vinIndexOfroot = i;
                break;
            }
        }
        //中序遍历中查询该元素并记录中序遍历该元素所在的索引
        //索引之前为左子树索引之后为右子树，并利用Arrays.copyOfRange 将左子树和右子树单独成树用于递归
       //int leftSize = vinIndexOfroot;
        int [] preExleft = Arrays.copyOfRange(pre,1,vinIndexOfroot+1);
        int [] vinExleft = Arrays.copyOfRange(vin,0,vinIndexOfroot);
        if(preExleft.length!=0){
            node.left = new TreeNode(preExleft[0]);
            reConstruct(node.left,preExleft,vinExleft);;
        }
        
        // int rightSize = pre.length-vinIndexOfroot-1;
        int [] preExright = Arrays.copyOfRange(pre,vinIndexOfroot+1,pre.length);
        int [] vinExright = Arrays.copyOfRange(vin,vinIndexOfroot+1,pre.length);
        if(preExright.length!=0){
            node.right = new TreeNode(preExright[0]);
            reConstruct(node.right,preExright,vinExright);
        }
    }
}


```

##### 优化

```
import java.util.*;
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
import java.util.Arrays;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if (pre.length == 0 || in.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(pre[0]);
        // 在中序中找到前序的根
        for (int i = 0; i < in.length; i++) {
            if (in[i] == pre[0]) {
                // 左子树，注意 copyOfRange 函数，左闭右开
                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                // 右子树，注意 copyOfRange 函数，左闭右开
                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
                break;
            }
        }
        return root;
    }
}
```

## 21-30

#### 21 树的子结构

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）



```
import java.util.*;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1==null||root2==null){
            return false;
        }
        LinkedList<TreeNode> Nodearray = new LinkedList();
        LinkedList<TreeNode> Node = new LinkedList();
        Node.add(root1);
        while(Node.size()!=0){
            TreeNode node = Node.poll();
            Nodearray.add(node);
            if(node.left!=null){
                Node.add(node.left);
            }
            if(node.right!=null){
                Node.add(node.right);
            }
        }
        for(int i=0;i<Nodearray.size();i++){
            if(Nodearray.get(i).val==root2.val){
                if(equalTree(Nodearray.get(i),root2)){
                    return true;
                }
            }
        }
        return false;

        //遍历root1树的结点root，当结点值等于root2时
        //判断root与root2是否相同
        //判断root的左子结点与root2的左子结点
        //有不等返回false
        //递归判断root.left
        //判断root的右子结点与root2的右子结点
        //有不等返回false
        //递归判断root.left
    }

    public boolean equalTree(TreeNode root1,TreeNode root2){
        if(root1.val!=root2.val){
            return false;
        }

        if((root1.left!=null&&root2.left!=null)){
            if(!equalTree(root1.left,root2.left)){//如果左子结点结构不相同则直接返回false
                return false;
            }
        }else if((root1.left==null&&root2.left!=null)){
            return false;
        }
        if((root1.right!=null&&root2.right!=null)){
            if(!equalTree(root1.right,root2.right)){
                return false;
            }
        }else if((root1.right==null&&root2.right!=null)){
            return false;
        }

        return true;
    }
}
import java.util.*;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1==null||root2==null){
            return false;
        }
        LinkedList<TreeNode> Nodearray = new LinkedList();
        LinkedList<TreeNode> Node = new LinkedList();
        Node.add(root1);

        //层序遍历原树
        while(Node.size()!=0){
            TreeNode node = Node.poll();
            Nodearray.add(node);
            if(node.left!=null){
                Node.add(node.left);
            }
            if(node.right!=null){
                Node.add(node.right);
            }
        }
        //逐个结点判断
        for(int i=0;i<Nodearray.size();i++){
                if(equalTree(Nodearray.get(i),root2)){
                    return true;
                }
        }
        return false;

        //遍历root1树的结点root，当结点值等于root2时
        //判断root与root2是否相同
        //判断root的左子结点与root2的左子结点
        //有不等返回false
        //递归判断root.left
        //判断root的右子结点与root2的右子结点
        //有不等返回false
        //递归判断root.left
    }

    public boolean equalTree(TreeNode root1,TreeNode root2){
        if(root1.val!=root2.val){
            return false;
        }

        if((root1.left!=null&&root2.left!=null)&&!equalTree(root1.left,root2.left)){
            //二者均有左子结构
            //同时如果左子结点结构不相同则直接返回false
            //否则判断右子结构的情况
                return false;
        }else if((root1.left==null&&root2.left!=null)){//当root1 无子结构时，若root2 有子结构则 返回false
            return false;
        }
        if((root1.right!=null&&root2.right!=null)&&!equalTree(root1.right,root2.right)){
                return false;
        }else if((root1.right==null&&root2.right!=null)){
            return false;
        }
        //子结构均相同返回true

        return true;
    }
}
```

#### 22 二叉树的镜像

操作给定的二叉树，将其变换为源二叉树的镜像。

```
比如：    源二叉树 
            8
           /  \
          6   10
         / \  / \
        5  7 9 11
        镜像二叉树
            8
           /  \
          10   6
         / \  / \
        11 9 7  5
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pRoot TreeNode类 
     * @return TreeNode类
     */
    public TreeNode Mirror (TreeNode pRoot) {
        if(pRoot==null){
            return pRoot;
        }
        TreeNode exnode = pRoot.left;
        pRoot.left = Mirror(pRoot.right);
        pRoot.right = Mirror(exnode);
        
        return pRoot;
        // write code here
    }
}
```

#### 23 二叉树的后序遍历 序列推断

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：**我们约定空树不是二叉搜索树**）

示例1

输入：

```
[4,8,6,12,16,14,10]
```

返回值：

```
true


import java.util.*;

public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        //如果数组为空 return false
        if(sequence.length<=0){
            return false;
        }
        int mid = sequence.length-1;//初始化必须注意，当只有左子树和根结点的情况
        //for循环计算不会break，此时分界点在根结点处
        
        //从根结点（尾元素）出发判断左右子树的分界线
        for(int i=0; i<sequence.length-1; i++){
            if(sequence[i]>sequence[sequence.length-1]){
                mid=i;
                break;
            }
        }
        //从分界线出发判断 分界线到根结点是否都满足右子树条件
        for(int j= mid+1; j<sequence.length-1; j++){
            //不满足返回 false
            if(sequence[j]<sequence[sequence.length-1]){
                return false;
            }
        }
        //满足则copy左子树 右子树到两个数组
        int [] left = Arrays.copyOfRange(sequence,0,mid);
        if(left.length<=0){
            return true;
        }
        
        int [] right = Arrays.copyOfRange(sequence,mid,sequence.length-1);
        if(right.length<=0){
            return true;
        }
        //递归进行判断
        return VerifySquenceOfBST(left)&&VerifySquenceOfBST(right);
    }
}

```

#### 24 二叉树中 和为某一值的路径

描述

输入一颗二叉树的根结点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

示例1

输入：

```
{10,5,12,4,7},22
```

复制

返回值：

```
[[10,5,7],[10,12]]
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/

public class Solution {
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
        ArrayList<ArrayList<Integer>> path = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> sub_path = new ArrayList<Integer>();
        checkPath(path,sub_path,root,target);
        return path;

    }
    public void checkPath(ArrayList<ArrayList<Integer>> path ,ArrayList<Integer> sub_path,TreeNode node ,int target){
        if(node==null){
            return;
        }
        //比较当前结点和target值的大小关系，
        //小于则 将target-node.val 用于下一次递归（左右结点）
        if(node.val<=target) {
            sub_path.add(node.val);
            target = target - node.val;
            checkPath(path, sub_path, node.left, target);
            checkPath(path, sub_path, node.right, target);
            //target==0,当前路径压入path
            if (target == 0 && node.left==null && node.right==null) {
                ArrayList<Integer> sub_path_copy = (ArrayList<Integer>) sub_path.clone();
                path.add(sub_path_copy);//由于sub_path是引用类型得所以直接传入后，后续sub_path的改变仍然会影响之前传入的sub——path
            }
            //最后移除当前sub_path最后结点****因为这里的sub_path类似于全局变量
            sub_path.remove(sub_path.size() - 1);
        }
    }

}
```

#### 25 二叉树与双向链表

描述

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示

```
import java.util.*;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<TreeNode> a = new ArrayList();
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree==null){
            return null;
        }
        ArrayList<TreeNode> array = mid_EG(pRootOfTree);
        for(int i=0; i<array.size()-1; i++){
            array.get(i).right=array.get(i+1);
            array.get(i+1).left=array.get(i);
        }
        return array.get(0);
    }
    
    public ArrayList<TreeNode> mid_EG(TreeNode node){
        if(node==null){
            return null;
        }
        mid_EG(node.left);
        a.add(node);
        mid_EG(node.right);
        return a;
    }
}
```

#### 26 把数组中的数组成最小值

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

输入：

```
[3,32,321]
```

返回值：

```
"321323"
//原理：输出的数组中 每个字符和其他任意字符的顺序组合都是 他们两种组合中的最小值 时 这个数组整体组成的数也就最小了

package com.practice;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Solution {
    public String PrintMinNumber(int [] numbers) {
        int n;
        String s="";
        ArrayList<Integer> list= new ArrayList<Integer>();
        n=numbers.length;
        for(int i=0;i<n;i++){
            list.add(numbers[i]);

        }
        Collections.sort(list, new Comparator<Integer>(){

            public int compare(Integer str1,Integer str2){
                String s1=str1+""+str2;
                String s2=str2+""+str1;
                return s1.compareTo(s2);
            }
        });

        for(int j:list){
            s+=j;
        }
        return s;

    }
}
```

#### 27 找到最小索引非重复字符

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

输入：

```
"google"
```

返回值：

```
4
import java.util.*;
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        //定义一个链表存储字符串索引
        LinkedList<Integer> list = new LinkedList();

        //循环将字符串的索引准备放入链表中
        for(int i=0; i<str.length(); i++){
            //判断如果链表中有当前要插入元素，remove 原链表索引
            //如果没有则插入
            int RepeatFlag = 0;
            for(int j=0; j<list.size(); j++){
                if(str.charAt(list.get(j))==str.charAt(i)){
                    list.remove(j);
                    RepeatFlag =1;
                    break;
                }
            }
            if(RepeatFlag!=1){
                list.add(i);
            }


        }
        if(list.size()==0){
            return -1;
        }

        return list.get(0);
        //返回第一个元素
    }
}
```

使用哈希表

**方法一：**哈希表

1、将字符当成哈希表中的key，第一次出现时候为true，重复出现则置为false；

2、遍历数组，拿到第一个在哈希表中的value为true的字符。

来看两张动图，简单易懂理解这种做法：

```
import java.util.*;
public class Solution {
public int FirstNotRepeatingChar(String str) {
        HashMap<Character,Boolean> map = new HashMap<>();
        char[] chars = str.toCharArray();
        // 初始化哈希表，重复出现的置为false，否则为true
        for(char c:chars){
            if(map.containsKey(c)){
                map.put(c,false);
            }else{
                map.put(c,true);
            }
        }
        // 二次遍历字符数组，若其在哈希表中的value为true，则返回下标
        for(int i = 0; i < chars.length; i++){
            if(map.get(chars[i])){
                return i;
            }
        }
        // 没有符合条件的则返回-1
        return -1;
    }
}
```

**方法二：**数组

巧妙利用字母的ASCII码，因为我们知道小写字母z的ASCII码值为122。所以我们可以使用计数的方法，开辟一个空间为123（数组下标从0开始）的数组，使用ASCII码（对应数组的下标）表示字母，去统计字母出现的次数。

最后我们只需要遍历一遍字符串，找到那个只出现一次的字符即可。由于很简单，我们直接看代码：

```
public int FirstNotRepeatingChar(String str) {
        // 开辟一个数组
        int[] dp = new int[123];  // 存储字母出现的次数  例如: dp[122] = 2，表示:小写字母z，出现了两次
        // 统计出现的次数
        for (int i = 0; i < str.length(); i++) {
            dp[str.charAt(i)]++;
        }
        // 遍历字符串，若字符只出现一次，则返回下标
        for (int i = 0; i < str.length(); i++) {
            if (dp[str.charAt(i)] == 1)
                return i;
        }
        return -1;
    }
```

#### 28 数组的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

对于50\%50%的数据,size\leq 10^4*s**i**z**e*≤104 对于100\%100%的数据,size\leq 10^5*s**i**z**e*≤105



输入描述：

题目保证输入的数组中没有的相同的数字

如果两个区间为[4, 3] 和[1, 2] 那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2]的结果是一样的，也就是说区间有序和无序结果是一样的。 但是如果区间有序会有什么好处吗？当然，如果区间有序，比如[3,4] 和 [1,2] 如果3 > 1, 显然3后面的所有数都是大于1， 这里为 4 > 1, 明白其中的奥秘了吧。所以我们可以在合并的时候利用这个规则。

示例1

输入：

```
[1,2,3,4,5,6,7,0]
```

返回值：

```
7
问题代码
//超时，没有很好的利用有序性减少计算量
package com.practice;
import java.util.*;

public class Solution {
    int N= 0;
    public int InversePairs(int [] array) {

        //分

        //判断数组大小是否大于1 否 return
        if(array.length<=1){
            return 0;
        }

        //取数组中心
        int mid = array.length/2;

        //将数组按照中心分割，分成两个数组
        int [] array_assisted1 = Arrays.copyOfRange(array,0,mid);
        int [] array_assisted2 = Arrays.copyOfRange(array,mid,array.length);

        //将着两个数组分别用于递归
        InversePairs(array_assisted1);
        InversePairs(array_assisted2);

        //并

        //判断合并数组的逆序情况
        int temp1 = array_assisted1.length-1;
        int temp2 = 0;
        
        //前数组中最大的 和 后数组中最小的进行比较

        while(temp1>=0 && array_assisted1[temp1]>array_assisted2[temp2]){
            while(temp2<array_assisted2.length &&array_assisted1[temp1]>array_assisted2[temp2]){
                    N++;
                    temp2++;
            }
            temp1--;
            temp2=0; //重置temp1
        }

        //如果前数组的第一个元素 大于 后一个数组的第一个元素，N + (array_assisted.size()-1)^2

        //数组排序并合并
        //定义两个指针指向两个辅助数组
        temp1 = 0;
        temp2 = 0;
        int i = 0;
        //比较指针索引的数据大小，小者插入到原数组中，并相后移动
        while(temp1<array_assisted1.length&& temp2<array_assisted2.length){
            if(array_assisted1[temp1]<array_assisted2[temp2]){
                array[i] = array_assisted1[temp1];
                temp1++;
            }else {
                array[i] = array_assisted2[temp2];
                temp2++;
            }
            i++;
        }
        while(temp1<array_assisted1.length){
            array[i] = array_assisted1[temp1];
            temp1++;
            i++;
        }
        while(temp2<array_assisted2.length){
            array[i] = array_assisted2[temp2];
            temp2++;
            i++;
        }

        return N;
    }
}

//从找逆序对出发，即找前数组中元素比后数组大的情况
//1. 遍历后数组 元素i； 
//循环 遍历前数组 前数组中只要有一个元素比 i大，那么不需要继续遍历，前数组后面元素的个数为新增逆序对数


import java.util.*;

public class Solution {
    int N= 0;
    public int InversePairs(int [] array) {

        //分

        //判断数组大小是否大于1 否 return
        if(array.length<=1){
            return 0;
        }

        //取数组中心
        int mid = array.length/2;

        //将数组按照中心分割，分成两个数组
        int [] array_assisted1 = Arrays.copyOfRange(array,0,mid);
        int [] array_assisted2 = Arrays.copyOfRange(array,mid,array.length);

        //将着两个数组分别用于递归
        InversePairs(array_assisted1);
        InversePairs(array_assisted2);

        //并

        //判断合并数组的逆序情况
        int temp1 = 0;
        int temp2 = 0;

        //从找逆序对出发，即找前数组中元素比后数组大的情况
        //1. 遍历后数组 元素i； 
        //循环 遍历前数组 前数组中只要有一个元素比 i大，那么不需要继续遍历，前数组后面元素的个数为新增逆序对数
        //i++;
        while(temp2<array_assisted2.length){
            while(temp1<array_assisted1.length){
                if(array_assisted1[temp1]>array_assisted2[temp2]){
                    N =(N + array_assisted1.length-temp1)%1000000007;
                    break;
                }
                temp1++;
            }
            temp2++;
        }

        //如果前数组的第一个元素 大于 后一个数组的第一个元素，N + (array_assisted.size()-1)^2

        //数组排序并合并
        //定义两个指针指向两个辅助数组
        temp1 = 0;
        temp2 = 0;
        int i = 0;
        //比较指针索引的数据大小，小者插入到原数组中，并相后移动
        while(temp1<array_assisted1.length&& temp2<array_assisted2.length){
            if(array_assisted1[temp1]<array_assisted2[temp2]){
                array[i] = array_assisted1[temp1];
                temp1++;
            }else {
                array[i] = array_assisted2[temp2];
                temp2++;
            }
            i++;
        }
        while(temp1<array_assisted1.length){
            array[i] = array_assisted1[temp1];
            temp1++;
            i++;
        }
        while(temp2<array_assisted2.length){
            array[i] = array_assisted2[temp2];
            temp2++;
            i++;
        }
        return N;
    }
}
```

#### 29 两个链表的第一个公共结点

描述

输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

示例1

输入：

```
{1,2,3},{4,5},{6,7}
```

返回值：

```
{6,7}
```

说明：

```
第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分
这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共结点的     
```

示例2

输入：

```
{1},{2,3},{}
```

返回值：

```
{}
```

说明：

```
2个链表没有公共结点 ,返回null，后台打印{} 
//利用两个堆栈存储两个链表的结点
//弹出堆栈，结点相同则继续弹出，不同则返回上一个结点
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if(pHead1==null||pHead2==null){
            return null;
        }
        Stack<ListNode> stack1 = new Stack();
        Stack<ListNode> stack2 = new Stack();
        ListNode temp = pHead1;
        while(temp!=null){
            stack1.push(temp);
            temp = temp.next;
        }
        temp = pHead2;
        while(temp!=null){
            stack2.push(temp);
            temp = temp.next;
        }
      
        ListNode node = null;
        while(stack1.size()>0&&stack2.size()>0&&(temp = stack1.pop())==stack2.pop()){
            node = temp;//用来存储temp的上一个结点
            
        }
        return node;
        
 
    }
}
```

**题解思路：**

使用两个指针N1,N2，一个从链表1的头结点开始遍历，我们记为N1，一个从链表2的头结点开始遍历，我们记为N2。

让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头结点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头结点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。

因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同结点，都能够到达同时到达终点。

（N1最后肯定能到达链表2的终点，N2肯定能到达链表1的终点）。

所以，如何得到公共结点：

- 有公共结点的时候，N1和N2必会相遇，因为长度一样嘛，速度也一定，必会走到相同的地方的，所以当两者相等的时候，则会第一个公共的结点
- 无公共结点的时候，此时N1和N2则都会走到终点，那么他们此时都是null，所以也算是相等了。

```
import java.util.*;
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
   public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode l1 = pHead1, l2 = pHead2;
        while(l1 != l2){
            l1 = (l1==null)?pHead2:l1.next;
            l2 = (l2==null)?pHead1:l2.next;
        }
        return l1;
    }
}
```

**题解思路二**

假设链表`A`长度为`a`， 链表`B`的长度为`b`，此时`a != b` 但是，`a+b == b+a` 因此，可以让a+b作为链表A的新长度，b+a作为链表B的新长度。

对于相同长度的链表如果有相遇的结点，以相同速度移动的话必然相遇



#### 30 计算树的最大深度

**思路一**：

分治法简介：求一个规模为n的问题，先求**左边**规模大约为n/2的问题，再求**右边**规模大约为n/2的问题，然后合并左边，右边的解，从而求得最终解。具体可参考归并排序。

```
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public int TreeDepth(TreeNode root) {
        int maxleft = 0;
        int maxright = 0;
        //如果有左子树递归计算左子树的最大深度
        if(root==null){
            return 0;
        }
        if(root.left!=null){
            maxleft = TreeDepth(root.left);
        }
         //如果有右子树递归计算右子树的最大深度
        if(root.right!=null){
            maxright = TreeDepth(root.right);
        }
        
        return maxright<maxleft? maxleft+1:maxright+1;
        //返回左右最大者+1
        
    }
}
```

**思路二**：

我们先来回顾一下二叉树的层次遍历，一般我们都是用队列去实现的。

步骤：

1、先创建一个队列，将根结点入队；

2、队列不为空，进入循环：

- 出队一个结点
- 将当前结点的左右结点入队（不为空时）
- 此时当前层的所有结点的左右子结点都入队

4、最后当队列中无结点的时候，此时已全部遍历完全部结点。

有了上面的步骤，我们只需要在每一层的所有结点的左右子结点都入完队的时候，就计数，最后则可以得到结果。



## 31-40

#### 31 平衡二叉树

输入一棵二叉树，判断该二叉树是否是平衡二叉树。

在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树

**平衡二叉树**（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

注：我们约定空树是平衡二叉树。

示例1

输入：

```
{1,2,3,4,5,6,7}
```

返回值：

```
true
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root==null){
            return true;
        }
        //判断左子树是否是平衡二叉树
        if(root.left!=null){
            if(!IsBalanced_Solution(root.left)){
                return false;
            }
        }
        //判断右子树是否是平衡二叉树
         if(root.right!=null){
            if(!IsBalanced_Solution(root.right)){
                return false;
            }
        }
        //判断左右子树的深度差是否大于1
        int x = TreeDepth(root.left)-TreeDepth(root.right);
        if(x<=1&&x>=-1){
             return true;
        }
        return false;

    }
    public int TreeDepth(TreeNode root) {
        int maxleft = 0;
        int maxright = 0;
        //如果有左子树递归计算左子树的最大深度
        if(root==null){
            return 0;
        }
        if(root.left!=null){
            maxleft = TreeDepth(root.left);
        }
         //如果有右子树递归计算右子树的最大深度
        if(root.right!=null){
            maxright = TreeDepth(root.right);
        }
        
        return maxright<maxleft? maxleft+1:maxright+1;
        //返回左右最大者+1
    }
}
```

#### 32 数组中只出现一次的两个数字

描述

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

示例1

输入：

```
[1,4,1,6]
```

返回值：

```
[4,6]
```

##### 利用数组索引

//正负值分别放在两个boolen数组中 ，boolen数组的程度等于原数组最大绝对值最大的元素值

//遍历数组，boolen数组中，对应数组元素值的索引 的boolen值取反

//其中 正boolen数组的为true的索引就是出现一次的数字 

//其中 负boolen数组的为true的索引取负号 就是出现一次的数字 

```
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param array int整型一维数组
     * @return int整型一维数组
     */

    public int[] FindNumsAppearOnce (int[] array) {
        if(array.length==0){
            return array;
        }
        int max = array[0];
        int min = array[0];
        for(int i = 0; i<array.length;i++)  {
            if(array[i]>=0&&array[i]>max){
                max=array[i];
            }
            if(array[i]<0&&array[i]<min){
                min=array[i];
            }
        }

        boolean[] b1 = new boolean[max+1];
        boolean[] b2 = new boolean[Math.abs(min)+1];

        for(int i = 0; i<array.length;i++)  {
            if(array[i]>=0){
                b1[array[i]]=!b1[array[i]];
            }
            if(array[i]<0){
                b2[-array[i]]=!b2[-array[i]];
            }
        }
        ArrayList<Integer> b = new ArrayList();
        for(int i = 0; i<b1.length ;i++)  {
            if(b1[i]==true){
                b.add(i);
            }
        }
        for(int i = 0; i<b2.length ;i++)  {
            if(b2[i]==true){
                b.add(-i);
            }
        }

        int [] returned = new int[b.size()];//ArrayLIst 转化成 int[]
        for(int i = 0; i<b.size(); i++){
            returned[i] = b.get(i);
        }
        return returned;
        // write code here
    }
}
```

##### 类似于hash 构造 

键值对 重复的为true 不重复的为false

```
import java.util.*;
public class Solution {
    class key_value{ //键值 内部类
        public int key;
        public boolean value;
        key_value(int key){
            this.key = key;
        }
    }
    public int[] FindNumsAppearOnce (int[] array) {
        ArrayList<key_value> k_v = new ArrayList();
        for(int i = 0; i<array.length;i++)  {
            boolean flag = false;
            for(int j = 0; j<k_v.size(); j++){ //遍历键值对数组，如果存在则反转 boolean值，
                if(k_v.get(j).key==array[i]){
                    k_v.get(j).value=!k_v.get(j).value;
                    flag = true;
                    break;
                 }
            }
            if(flag==false)//不存在则 添加到键值数组中
            k_v.add(new key_value(array[i]));
        }
        ArrayList<Integer> b = new ArrayList(); //从键值数组中提取boolean值为true的 数据 key
        for(int i = 0; i<k_v.size() ;i++) {
            if(k_v.get(i).value==false){
                b.add(k_v.get(i).key);
            }
        }
        int [] returned = new int[b.size()]; //ArrayLIst 转化成 int[]
        for(int i = 0; i<b.size(); i++){
            returned[i] = b.get(i);
        }
        return returned;
        // write code here
    }
}
```

##### 直接用HashMap

```
import java.util.*;


public class Solution {

    public int[] FindNumsAppearOnce (int[] array) {
        // write code here
        // 用于返回结果
        int[] res = new int[2];
        // 创建一个哈希表
        HashMap<Integer,Object> set = new HashMap<>();
        for(int i = 0; i < array.length; i++){
            // 如果已经被当作key了，那就直接remove掉
            if(set.containsKey(array[i])){
                set.remove(array[i],null);
            }else{
                // 否则就添加进去
                set.put(array[i],null);
            }
        }
        int i = 0;
        // 最后拿出来放进返回结果的数组中进行返回
        for(Integer num:set.keySet()){
            res[i++] = num;
        }
        return res;
    }
}
```

##### **位运算**

用异或^可解此题。

但是首先要知道一个知识点，a^b^a = a^a^b = b^a^a =b，这个知识点也就是本题的简单版本：如果数组中除了某一个数字，其他数字都出现了两次，找出该数字。思路就是遍历数组，对每一个数字都求异或，最后得到的值就是要找的数字。

有了该知识点的储备，再来看看本题。本题是要找两个数字a和b，那我们把该数组分成两个数组，其中a和一部分出现两次的数字在一块儿，b和另一部分出现两次的数字在一块儿，那这两个数组不是就变成了上面讲的那个简单版本中的数组吗？然后再分别对这两个数组求异或，就可以找到这两个数字了。

举例：[a,2,2,3,3,b]。把该数组分成[a,2,2]和[3,3,b]，再对这两个数组求异或，便能得到a和b。

问题：怎么把a和b区分开来？

可以利用二进制来区分。先对整个数组求异或得到c，根据上面的知识，可以知道c其实就是a^b=c。那么对于c，假如c二进制的第一位是1，其实就代表a二进制的第一位是1（或0），b二进制的第一位是0（或1），总而言之如果第一位的c等于1，那么a和b在第一位肯定不相等。

所以我们就可以想到利用二进制的第一位（有可能是第二位，第三位 。。。因为上面是假设的c第一位是1）为1来区分两个数组，第一位为1的是数组一，第一位为0的是数组二。这样就相当于把a和b给区分开来了。

a和b区分开以后，剩下的就简单了，判断数组中其他数字的二进制的第一位是否为1，是的话就分到数组一，为0就分到数组二。最后对数组一和数组二分别进行异或，得到的就是a和b。

有个地方没有讲清楚，利用二进制的第一位为1来区分两个数组，如果第一位不是1，那就判断第二位，第三位，一直到找到为1的地方。假设一直找到第n位才为1，那就判断数组中的其他数字的二进制的第n位是否为1，做&运算即可判断。

位运算感觉还是挺抽象的，我也是用具体的例子来照着别人的代码推一遍才搞明白，为什么那个地方做&运算就可以得到它，为什么那个地方做^运算又可以得到它。要是还没看懂的小伙伴也可以自己写一个具体的数组，然后照着代码先在草稿纸上推一遍，多搞几次就明白了。

```
import java.util.*;
public class Solution {

    public int[] FindNumsAppearOnce (int[] array) {
        // write code here
        // 用于返回结果
        //所有元素取异或运算
        if(array.length==0){
            return array;
        }
        int spilt = array[0];
        for(int i=1; i<array.length; i++){
            spilt = array[i]^spilt;
        }
        //输出的结果取第一个位数等于1的位置，构造二进制数
        int t = 1;
        while(true){
            if((spilt&t)==t){
                break;
            }
            t=t<<1;
        }
        //利用此二进制数和全体元素取与
        ArrayList<Integer> array1 = new ArrayList();
        ArrayList<Integer> array2 = new ArrayList();
        
        for(int i=0; i<array.length; i++){
            if((array[i]&t)==t){
                array1.add(array[i]);
            }else{
                array2.add(array[i]);
            }
        }
        //等于0的分到一组 等于1的分到一组
        int[] submit =new int [2];
        submit[0] = array1.get(0);
        for(int i=1; i<array1.size(); i++){
            submit[0] = array1.get(i)^submit[0];
        }
        submit[1]=array2.get(0);
        //两组数组分别输入到FIndNumOne
        for(int i=1; i<array2.size(); i++){
            submit[1] = array2.get(i)^submit[1];
        }
        Arrays.sort(submit);
        //数据整合到数组中
        return submit;
    }   
  
}
//优化
import java.util.*;
public class Solution {

    public int[] FindNumsAppearOnce (int[] array) {
        // write code here
        // 用于返回结果
        //所有元素取异或运算
        if(array.length==0){
            return array;
        }
        int spilt = array[0];
        for(int i=1; i<array.length; i++){
            spilt = array[i]^spilt;
        }
        //输出的结果取第一个位数等于1的位置，构造二进制数
        int t = 1;
        while(true){
            if((spilt&t)==t){
                break;
            }
            t=t<<1;
        }
        //利用此二进制数和全体元素取与
        //等于0的分到一组 等于1的分到一组
        int[] submit ={0,0};
        for(int i=0; i<array.length; i++){
            if((array[i]&t)==t){
                submit[0] = array[i]^submit[0];
            }else{
                submit[1] = array[i]^submit[1];
            }
        }
      
        Arrays.sort(submit);
        //数据整合到数组中
        return submit;
    }
}
```

#### 33 数字出现的次数超过数组长度的一半

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1<=数组长度<=50000，0<=数组元素<=10000

输入：

```
[1,2,3,2,2,2,5,4,2]
```

返回值：

```
2
```

##### 哈希表

```
package com.practice;
import java.util.*;

public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        int length = array.length;
        HashMap<Integer,Integer> hash = new HashMap();
        for(int i=0; i<length; i++){
            if(hash.containsKey(array[i])){
                hash.put(array[i],hash.get(array[i])+1);
            }else{
                hash.put(array[i],1);
            }
        }
        for(Integer i:hash.keySet()){
            if(hash.get(i)>length/2){
                return i;
            }
        }
        return -1;
    }
}
```

##### 排序

取中位数

##### 攻守阵地

采用阵地攻守的思想： 第一个数字作为第一个士兵，守阵地；count = 1； 遇到相同元素，count++; 遇到不相同元素，即为敌人，同归于尽,count--；当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。 再加一次循环，记录这个士兵的个数看是否大于数组一般即可。

```
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        int count = 1;
        int x = array[0];//给x一票
        for(int i=1; i<array.length; i++){
            if(x!=array[i]){
                count--;//遇到反对者 减一票
            }else{
                count++;//遇到同意者 加一票
            }
            if(count==0){//重新设置X为新array[i];
                x = array[++i];//i=i+1；x=array[i]    x = array[i++] --- x = array[i];i=i+1
                count=1;
            }
        }
        return x;
    }
}
```

#### 34 和为S的两个数

描述

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回两个数的乘积最小的，如果无法找出这样的数字，返回一个空数组即可。

返回值描述：

对应每个测试案例，输出两个数，小的先输出。

示例1

输入：

```
[1,2,4,7,11,15],15
```

返回值：

```
[4,11]
```



##### 两层for

思路一两层for遍历每一对

```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        ArrayList<Integer> a = new ArrayList();
        for(int i=0; i<array.length; i++){
            for(int j=i+1; j<array.length ;j++){
                if(array[i]+array[j]==sum){
                    if(a.size()!=0){
                        
                        if(a.get(0)*a.get(1)>array[i]*array[j]){
                            a.clear();
                        }else{
                            break;
                        }
                        
                    }
                    a.add(array[i]);
                    a.add(array[j]);
                }
            }
        }
        
        return a;
        
    }
}
```

##### 双指针

利用题目递增排序的规律

```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        ArrayList<Integer> a = new ArrayList();
         if(array.length==0){
            return a;
        }
        int i=0;
        int j=array.length-1;//双指针
        while(i!=j){
            int S = array[i]+array[j]; 
            if(S == sum){
                 a.add(array[i]);
                 a.add(array[j]);
                 break;
            }
            if(S < sum){
                i++;
             }
            if(S > sum){
                j--;
              }
            
        }
        return a;
        
    }
}
```

##### **二分查找**

解题思路： 利用数组递增排序的特性，满足二分查找条件。 主要思路：

1. 假设当前值为arr[i], 那么第二个数为sum-arr[i]。

2. sum-arr[i] 与 arr[i]的大小分为三种情况： a. 如果sum-arr[i] arr[i]相等，那么只需要查找i两侧的值； b. 如果sum-arr[i]小于arr[i]，那么在i 的左侧查找sum-arr[i]; c. 如果sum-arr[i]大于arr[i], 那么在i 的右测查找sum-arr[i];

   

#### 35 字符串循環左移

汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）。例如，字符序列S=”abcXYZdef”,要求输出循环左移 3 位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

示例1

输入：

```
"abcXYZdef",3
```

返回值：

```
"XYZdefabc"
//API的使用

public class Solution {
    public String LeftRotateString(String str,int n) {
        if(n>str.length()){
            return "";
        }
        char[] c = str.toCharArray();
        return String.copyValueOf(c,n,c.length-n)+String.copyValueOf(c,0,n);
    }
}


public class Solution {
    public String LeftRotateString(String str,int n) {
        if(n>str.length()){
            return "";
        }
  
        return str.substring(n)+str.substring(0,n);
    }
}
```

#### 36 翻转单词序列

描述

牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？

示例1

输入：

```
"nowcoder. a am I"
```

返回值：

```
"I am a nowcoder."
public class Solution {
    public String ReverseSentence(String str) {
     
        String[] SArray = str.split(" ");
        if(SArray.length==0){
            return "";
        }
        String S = SArray[SArray.length-1];
        for(int i=SArray.length-2; i>=0; i--){
            S=S+" "+SArray[i];
        }
        return S;
    }
}
```

也可以考虑不用库函数，直接用栈

#### 37 扑克牌顺子

现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。 有如下规则： \1. A为1，J为11，Q为12，K为13，A不能视为14 \2. 大、小王为 0，0可以看作任意牌 \3. 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。 例如：给出数据[6,0,2,0,4] 中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4] 这样这五张牌在[2,6]区间连续，输出true 数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]

示例1

输入：

```
[6,0,2,0,4]
```

返回值：

```
true
```

##### 先排序，再用守阵地模式

```
import java.util.*;
public class Solution {
    public boolean IsContinuous(int [] numbers) {
        //归并排序
        Arrays.sort(numbers);
        int count = 0;
        int d = 1;
        //遍历0的个数 count
        for(int i=0; i<numbers.length-1; i++){
               //当元素不等于0时，计算相邻两个元素的距离d
            d = numbers[i+1]-numbers[i];
            if(numbers[i]==0){
                count++;
            }else if(d==0){
                //如果d等于0 return false
                return false;
            }else if(d>1){
                //如果d大于1 则 count-d-1
                count = count - d + 1;
            }
        }
        if(count<0){
            return false;
        }
        return true;
    }
}
```

##### 集合set + 遍历最大最小

根据题意，此 55 张牌是顺子的 充分条件 如下：  除大小王外，所有牌 无重复 ；  设此 55 张牌中**最大的牌为 max ，最小的牌为 min （大小王除外），则需满足**

​                                    **max - min < 5**

**算法：**

1、遍历五张牌，**遇到大小王（即 0 ）直接跳过。** 2、判别重复： 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1) ； 3、获取最大 / 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可



#### 38 约瑟夫问题

首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1

示例1

输入：

```
5,3
```

返回值：

```
3
package com.practice;
import java.util.*;
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        LinkedList<Integer> circle = new LinkedList();
        for(int i=0; i<n; i++){
            circle.add(i);
        }
        int i=0;
        while(circle.size()!=1){

            int count=0;
            while(count!=m-1){
                i++;//索引项
                count++;//计数项
                if(i>circle.size()-1){ //环形链表条件
                    i=0;
                }
            }
            circle.remove(i);//如果i是最后一个元素此时 应该指向0
            if(i>circle.size()-1){
                i=0;
            }
        }
        return circle.getFirst();
    }
}



import java.util.*;
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if(n==0){
            return -1;
        }
        LinkedList<Integer> circle = new LinkedList();
        for(int i=0; i<n; i++){
            circle.add(i);
        }
        int i=0;
        while(circle.size()!=1){
            i = i+m-1;//直接通过计算 找到需要删除的索引
            while(i>circle.size()-1){
                i = i- circle.size();
            }
            circle.remove(i);

        }
        return circle.getFirst();
    }
}   
```

#### 39 机器运算加减法

补充知识：

1. 补码 计算机中存整数n是用补码存的。

- 如果n为正数，则原码=反码=补码
- 如果n为负数，则补码=反码+1

1. 负数的右移:需要保持数为负数,所以操作是对负数的二进制位左边补1。如果一直右移,最终会变成-1,即(-1)>>1是-1。 
2. 负数的左移:和整数左移一样,在负数的二进制位右边补0,一个数在左移的过程中会有正有负的情况,所以切记负数左移不会特殊处理符号位。如果一直左移,最终会变成0。

主体思路： 面对本题，一般思路 1、在计算机内部的操作都是由门电路实现，加法也一定由位运算实现； 2、不确定使用何种位运算情况，可以进行打表找规律（如下）；

| A(i) | B(i) | 求和 | 进位 |
| :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |
|  0   |  1   |  1   |  0   |
|  1   |  0   |  1   |  0   |
|  1   |  1   |  0   |  1   |

如上图所示， (1) 当前位的和值等于 A(i)^B(i) (2) 进位等于 A(i)&B(i),进位需要加在计算位的前一位，所以左移1位，即A(i)&B(i)<<1 所以找出规律 A+B=A^B+(A&B)<<1; 接下来验证规律是否正确

|         A=8          | **0** | **1** | **0** | **0** | **0** |
| :------------------: | :---: | :---: | :---: | :---: | :---: |
|       **B=11**       | **0** | **1** | **0** | **1** | **1** |
|    **求和(A^B)**     | **0** | **0** | **0** | **1** | **1** |
| **求进位((A&B)<<1)** | **1** | **0** | **0** | **0** | **0** |
|  **进位+求和(A+B)**  | **1** | **0** | **0** | **1** | **1** |

8+11=19符合规律

整理完思路，实现代码：

```
public class Solution {
    public int Add(int num1,int num2) {
        int num = 0;
        while(num2!=0){
            num = num1^num2;
            num2 = (num1&num2)<<1;
            num1 = num;
        }
        return num1;
    }
}
```

#### 40 前n求和

题目重述：求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

##### 递归

```
public class Solution {
    public int Sum_Solution(int n) {
        if(n==1){
            return 1;
        }
        return n+Sum_Solution(n-1);
    }
}
```

##### 公式

```
public class Solution {
    public int Sum_Solution(int n) {
        return ((n+1)*n)/2;
    }
}

```

## 41-50

#### 41 数组中重复的数字

描述

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1

示例1

输入：

```
[2,3,1,0,2,5,3]
```

返回值：

```
2
```

说明：

```
2或3都是对的
```

##### hash

```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param numbers int整型一维数组 
     * @return int整型
     */
    public int duplicate (int[] numbers) {
        HashMap<Integer,Integer> hash = new HashMap();
        for(int i=0; i<numbers.length; i++){
            if(hash.containsKey(numbers[i])){
                return numbers[i];
            }else{
                hash.put(numbers[i],null);
            }
        }
        return -1;
        // write code here
    }
}
```

##### 替换法

```
 //解题思路
    /*替换法（O(n),O(1)）
    数组存放原则：numbers[i] = i
    遍历数组所有元素，交换不符合数组存放原则的元素：
        例如[2,3,1,0,2]
        遍历0位元素2：（交换0位元素2和2位元素1）->[1,3,2,0,2]
        遍历0位元素1：（交换0位元素1和1位元素3）->[3,1,2,0,2]
        遍历0位元素3：（交换0位元素3和3位元素0）->[0,1,2,3,2]
        依次遍历0、1、2、3位置元素，都符合存放原则numbers[i] = i，不做任何操作
        遍历末位元素2，此时末位元素2和2位元素2相等，出现了两次，即数字2位重复元素
     */
    public int duplicate (int[] numbers) {
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] != i){
                if (numbers[i] == numbers[numbers[i]]) return numbers[i];
                int temp = numbers[numbers[i]];
                numbers[numbers[i]] = numbers[i];
                numbers[i] = temp;
                i--;//遍历完0位元素以及交换完数字后，如果0位元素仍不符合数组存放原则：numbers[i] = i，那么还要重新遍历0位元素
            }
        }
        return -1;
    }
```

##### 排序+遍历

解题思路: 1、对数组进行排序(手写推荐:堆排序,系统函数:sort()),此步骤时间复杂度O(nlog(n)); 2、遍历数组，查看相邻元素是否有相等的，有直接返回结果，此步骤时间复杂度O(n);

**复杂度分析：** 时间复杂度:O(nlog(n)),上面已经分析出时间复杂度 空间复杂度:O(1)

#### 42 字符串转化成数字

补充：

**部分数字的ASCII码如下：** **数字0的ASCII码为十六进制数30，十进制数48** **数字1的ASCII码为十六进制数31，十进制数49** **数字2的ASCII码为十六进制数32，十进制数50** **数字3的ASCII码为十六进制数33，十进制数51** **数字4的ASCII码为十六进制数34，十进制数52** **数字5的ASCII码为十六进制数35，十进制数53** **数字6的ASCII码为十六进制数36，十进制数54** **数字7的ASCII码为十六进制数37，十进制数55** **数字8的ASCII码为十六进制数38，十进制数56** **数字9的ASCII码为十六进制数39，十进制数57** **ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。**

##### ASCLL

```
import java.util.*;
public class Solution {
    public int StrToInt(String str) {
        if(str.length()==0){
            return 0 ;
        }
        //检查首字符是否为+-;为正的话“删除”;为负数的话记录标记
        char[] cs= str.toCharArray();
        int index =0;
        //遍历数组，每个字符 - “0”，得到的结果如果大于9或者小于0，则返回0
        if(cs[0]=='+'||cs[0]=='-'){
            index = 1;
        }

        //否则 将差的结果*length*10
        int number = 0;
        int bitnumber = 0 ;
        for(int i = index; i<cs.length; i++ ){
            bitnumber = cs[i]-'0';
            if(bitnumber>9||bitnumber<0){
                return 0;
            }else {
                number = number*10 + bitnumber ;
            }
        }
        if(cs[0]=='-'){
            return -number;
        }else {
            return number;
        }

        //返回数字 含有标志
    }
}
```

注意：ret  *  10是  **可能溢出的**。比如当ret=214748365，ret * 10=2147483650，大于INT_MAX。我们不能将乘过后的值与INT_MAX比较，因为我们没有那么到空间存储ret * 10=2147483650。但是我们可以反过来思考，当ret>214748364时，必然不可以进行乘10操作。这时候如果依然需要转换，直接返回INT_MAX即可。

同理当ret*10没有超出int范围，ret*10+s[i]依然可能会超出int范围，我们只需要加一个判断即可，当ret*10=2147483640**,s[i]>'7'即可判定它会溢出**，返回INT_MAX即可。

#### 43 和为S的连续正数序列

输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序

示例1

输入：

```
9
```

返回值：

```
[[2,3,4],[4,5]]
```

##### 公式+遍历

```
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
       ArrayList<ArrayList<Integer>>array = new ArrayList();
        //分析了一下，sum/2+1之后不会有这样的序列了
        //之后利用公式(i+j)*(j-i+1)/2;暴力解
       for(int i = 1; i<=sum/2+1; i++){
           for(int j = i+1; j<=sum/2+1; j++){
               int SUM = (i+j)*(j-i+1)/2;
               if(SUM>sum){
                   break;
               }
               if(SUM == sum){
                   ArrayList<Integer> a = new ArrayList();
                   for(int k = i; k<=j; k++){
                       a.add(k);
                   }
                   array.add(a);
               }
           }
       }
       return array;
    }
}
```

##### 双指针滑动窗口

```
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        //存放结果
        ArrayList<ArrayList<Integer> > result = new ArrayList<>();
        //两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小
        int plow = 1,phigh = 2;
        while(phigh > plow & ( phigh<=(sum/2+1) ) ){
            //由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2
            int cur = (phigh + plow) * (phigh - plow + 1) / 2;
            //相等，那么就将窗口范围的所有数添加进结果集
            if(cur == sum){
                ArrayList<Integer> list = new ArrayList<>();
                for(int i=plow;i<=phigh;i++){
                    list.add(i);
                }
                result.add(list);
                plow++;
            //如果当前窗口内的值之和小于sum，那么右边窗口右移一下
            }else if(cur < sum){
                phigh++;
            }else{
            //如果当前窗口内的值之和大于sum，那么左边窗口右移一下
                plow++;
            }
        }
        return result;
    }
}

```



#### 44  构建乘积数组

描述

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）

对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。

示例1

输入：

```
[1,2,3,4,5]
```

返回值：

```
[120,60,40,30,24]
```

##### 遍历+剔除

```
import java.util.*;
public class Solution {
    public int[] multiply(int[] A) {
        if(A.length==1){
            return null;
        }
        int[] B =new int[A.length];
        Arrays.fill(B,1);
        for(int i = 0; i<B.length; i++){
            for(int j = 0; j<A.length; j++){
                if(j!=i)//剔除
                B[i] = B[i]*A[j];
            }
        }
        
        return B;
    }
}
```

##### 表格分区+遍历

| B[0]=   | 1    | A[1] | A[2] | ...  | A[n-2] | A[n-1] |
| ------- | ---- | ---- | ---- | ---- | ------ | ------ |
| B[1]=   | A[0] | 1    | A2   | ...  | A[n-2] | A[n-1] |
| B[2]=   | A[0] | A1   | 1    | ...  | A[n-2] | A[n-1] |
| ...     | ...  | ...  | ...  | ...  | ...    | ...    |
| B[n-2]= | A[0] | A[1] | A[2] | ...  | 1      | A[n-1] |
| B[n-1]= | A[0] | A[1] | A[2] | ...  | A[n-2] | 1      |

**左下角部分：从上到下计算并保存累乘结果**

**右上角部分：从下到上计算并保存累乘结果**

left[i] = A[0]  *..... *A[i-1]; left[i+1] = left[i] * A[i];

right[i] = A[i+1]*.....A[n-1]; right[i-1] = A[i] * right[i]];

B[i] = left[i]*right[i];

```
import java.util.*;
public class Solution {
    public int[] multiply(int[] A) {
        if(A.length==1){
            return null;
        }
        int[] B =new int[A.length];
        int[] left =new int[A.length]; 
        left[0] = 1;
        int[] right =new int[A.length];
        right[A.length-1]=1;
// left[i] = A[0]  *..... *A[i-1];
        for(int i = 1; i<A.length; i++){
            left[i]=left[i-1]*A[i-1];
        }
// left[i+1] = left[i] * A[i];
// right[i] = A[i+1]*.....A[n-1];
         for(int i = A.length-2; i>=0; i--){ // 注意等于0
            right[i]=right[i+1]*A[i+1];
        }
// right[i-1] = A[i] * right[i]];
        for(int i = 0; i<A.length; i++){
            B[i] = right[i]*left[i];
        }

// B[i] = left[i]*right[i];
        
        return B;
    }
}
```



#### 45 链表中环入口的结点

##### 快慢指针

```
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead) {
        //快慢两个指针相遇时，此时使用临时指针指向首结点，临时指针和慢指针同时移动，相遇处就是环入口；
        ListNode fastNode = pHead;
        ListNode lowNode = pHead;
        ListNode temp = pHead;
        while(fastNode.next!=null&&fastNode.next.next!=null){
            fastNode = fastNode.next.next;
            lowNode = lowNode.next;
            if(fastNode == lowNode){//相遇
                 while(temp!=lowNode){
                     temp = temp.next;
                     lowNode = lowNode.next;
                   }
                 return lowNode;
            }
        
        }
        return null;
    }
}
```

##### 哈希法

1. 遍历单链表的每个结点
2. 如果当前结点地址没有出现在set中，则存入set中
3. 否则，出现在set中，则当前结点就是环的入口结点
4. 整个单链表遍历完，若没出现在set中，则不存在环



#### 46 删除链表中的重复结点

描述

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

示例1

输入：

```
{1,2,3,3,4,4,5}
```

返回值：

```
{1,2,5}
```

##### 堆栈

1、遍历链表，利用栈中存放结点 2、比较当前结点和栈中的末尾元素: 相等则继续遍历后续的结点直到遍历到 不等的结点node 或者null 3、弹栈并判断，栈的大小是否=0（前方还是否有结点/栈中的末尾元素）：等于0则，重置pHead；不等于0则将栈中的末尾元素指向不等的结点node

```
import java.util.*;
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead) {
        if(pHead==null){
            return pHead;
        }
        Stack<ListNode> stack = new Stack();
        stack.push(pHead);
        ListNode cur = pHead.next;

        while(cur!=null){
            if(stack.lastElement().val==cur.val){
            
                //寻找后续重复元素
                while(cur!=null&&stack.lastElement().val==cur.val){
                    cur = cur.next;//删除全部重复元素
                }
                stack.pop();//弹出重复元素

                if(stack.size()!=0){//重复元素前还存在结点
                    stack.lastElement().next = cur;
                }else{//重复元素前不存在结点
                    pHead = cur;
                }
                
            }
            
            stack.push(cur);
            if(cur!=null)
            cur = cur.next;
            
        }
        return pHead;
    }
}
```



```
//仅删除重复结点
import java.util.*;
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead) {
        if(pHead==null){
            return pHead;
        }
        HashMap<Integer,Object> hash = new HashMap();
        ListNode temp =pHead;
        hash.put(temp.val,null);
        while(temp!=null&&temp.next!=null){
            if(hash.containsKey(temp.next.val)){
                temp.next = temp.next.next;
            }
            hash.put(temp.next.val,null);
            temp = temp.next;
        }
        return pHead;

    }
}
```

##### set+两次遍历

根据题意，显然如果能够知道重复的值是什么，然后再遍历一次单链表，删除重复值即可。 找重复值的具体步骤： 1.初始化：set<int> st \2. 遍历单链表相邻两个元素，如果相等，就加入到set当中 \3. 直到单链表遍历完</int>

删除重复值的具体步骤： 1.初始化：pre指针指向重复值的前一个结点，cur指向当前遍历的结点值 2.遍历单链表当前元素，然后再set中检查，如果是重复值，就删除，pre->next = cur->next \3. 否则，不是重复值，pre = pre->next, cur = cur->next \4. 知道单链表遍历完

#### 47 二叉树的下一个结点

给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个结点的二叉树。树中从父结点指向子结点的指针用实线表示，从子结点指向父结点的用虚线表示

![img](https://uploadfiles.nowcoder.com/images/20210616/557336_1623844408327/D03B8D5BB902D4516BB92CB216E58EC4)

示例:

输入:{8,6,10,5,7,9,11},8

返回:9

解析:这个组装传入的子树根结点，其实就是整颗树，中序遍历{5,6,7,8,9,10,11}，根结点8的下一个结点就是9，应该返回{9,10,11}，后台只打印子树的下一个结点，所以只会打印9，如下图，其实都有指向左右孩子的指针，还有指向父结点的指针，下图没有画出来

![img](https://uploadfiles.nowcoder.com/images/20210616/557336_1623845692021/E647707AEF2A4AE2C40F0FCCB549B6A5)

输入描述：

输入分为2段，第一段是整体的二叉树，第二段是给定二叉树结点的值，后台会将这2个参数组装为一个二叉树局部的子树传入到函数GetNext里面，用户得到的输入只有一个子树根结点

返回值描述：

返回传入的子树根结点的下一个结点，后台会打印输出这个结点

示例1

输入：

```
{8,6,10,5,7,9,11},8
```

返回值：

```
9
```

##### 中序遍历+数组遍历

```
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
import java.util.*;
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        //找到根结点
        TreeLinkNode root = pNode;
        while(root.next!=null){
            root = root.next;
        }
        //中序遍历 //返回TreeLinkNode数组
        ArrayList<TreeLinkNode> array = new ArrayList();
        midEg(root,array);
        //通过pNode遍历到下一个结点
        int i = 0;
        while(array.get(i)!=pNode){
            i++;
        }
        if(i+1>array.size()-1){
            return null;
        }
        return array.get(i+1);
        
    }
    public void midEg(TreeLinkNode Node, ArrayList<TreeLinkNode> array){
        if(Node.left!=null){
            midEg(Node.left, array);
        }
        if(Node!=null){
            array.add(Node);
        }
       // midEg(Node, array);
        if(Node.right!=null){
            midEg(Node.right, array);
        }
    }
}
```

##### 算法：模拟

中序遍历的顺序是左根右； 分类讨论： 1、如果遍历到了当前结点，当前点如果有右儿子，那它的后继是右子树中最左边的一个； 左中右：如果当前结点有右子树（想象成 中结点），那么他的后继结点在右边，右子树的最左边；

2、当前结点没有右子树，那么要沿着它的父结点往上找，找到第一个是其父结点的左儿子的结点，该结点的父结点就是当前结点的后继。 左中右：如果当前结点没有右子树（想象成 **该结点在某结点Node的左子树**），那么找到他的后继结点Node

- 首先向上找父节点pNode
- 直到某个pNode为mNode的左子节点时
- mNode即为Node；

时间复杂度:O(h) 不论往上找还是往下找，总共遍历的结点数都不大于树的高度。所以时间复杂度是 O(h)，其中 h 是树的高度。

```
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
import java.util.*;
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode) {
//       中序遍历的顺序是左根右；
// 分类讨论：
// 1、如果遍历到了当前结点，当前点如果有右儿子，那它的后继是右子树中最左边的一个；
        if(pNode.right!=null){
            return Getlast_leftNode(pNode.right);
        }else{
// 2、当前结点没有右子树，那么要沿着它的父结点往上找，找到第一个是其父结点的左儿子的结点，该结点的父结点就是当前结点的后继。
            return GetFather_IFLeftNode(pNode);
        }
        
     public TreeLinkNode Getlast_leftNode(TreeLinkNode Node){
// 左中右：如果当前结点有右子树（想象成 中结点），那么他的后继结点在右边，右子树的最左边；
         if(Node.left!=null){
             return Getlast_leftNode(Node.left);
         }
         return Node;
     }
        
    public TreeLinkNode GetFather_IFLeftNode(TreeLinkNode Node){
// 左中右：如果当前结点没有右子树（想象成 **该结点在某结点Node的左子树**），那么找到他的后继结点Node
// - 首先向上找父节点pNode
// - 直到某个pNode为mNode的左子节点时(此时mNode = pNode.Next)
// - mNode即为Node；
        if(Node.next != null){
            if(Node.next.left == Node){
                return Node.next;
            }else{
                return GetFather_IFLeftNode(Node.next);
            }
        }
        return null;
     }
}
```

#### 48 对称二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

输入：

```
{8,6,6,5,7,7,5}
```

##### 层序遍历

层序遍历即可 1、 如果有左子树、层序遍历左子树

2、如果右子树、逆向层序遍历右子树

3、层序遍历时注意 空的叶子节点(度为1的结点的空孩子节点)，用0替换；

4、比较两个树

```
import java.util.*;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
// 如果有左子树

//层序遍历左子树

//如果右子树

//逆向层序遍历右子树

//比较两个树


public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        if(pRoot==null){
            return true;
        }
        ArrayList<Integer> arrayLeft = new ArrayList();
        ArrayList<Integer> arrayRight = new ArrayList();
        // 如果有左子树
        if(pRoot.left!=null){
            arrayLeft = layerEG(pRoot.left);
        }
        //层序遍历左子树

        //如果右子树
        if(pRoot.right!=null){
            arrayRight = RlayerEG(pRoot.right);
        }
        //逆向层序遍历右子树
        //比较两个树
        if(Arrays.equals(arrayLeft.toArray(),arrayRight.toArray())){
            return true;
        }
        return false;
    }
    public ArrayList layerEG(TreeNode node){
        Stack<TreeNode> que = new Stack();
        ArrayList<Integer> array = new ArrayList();
        TreeNode temp;
        que.add(node);
        while(que.size()!=0){
            temp = que.pop();
            if(temp!=null){

                array.add(temp.val);
                if(temp.left!=null){
                    que.add(temp.left);
                }else{
                    que.add(null);;//特别注意：层序遍历 叶子节点 相等元素 非对称 左右节点
                }
                if(temp.right!=null){
                    que.add(temp.right);
                }else{
                    que.add(null);
                }

            }else {
                array.add(0);//空的叶子节点 用0占位
            }


        }

        return array;

    }

    public ArrayList RlayerEG(TreeNode node){
        Stack<TreeNode> que = new Stack();
        ArrayList<Integer> array = new ArrayList();
        TreeNode temp;
        que.add(node);
        while(que.size()!=0){
            temp = que.pop();
            if(temp!=null){
                array.add(temp.val);
                if(temp.right!=null){
                    que.add(temp.right);
                }else{
                    que.add(null);
                }
                if(temp.left!=null){
                    que.add(temp.left);
                }else{
                    que.add(null);
                }
            }else{
                array.add(0);
            }
        }
        return array;
    }
}

```

##### 递归

1、如果有左右子树，判断左右子树是否对称相等

2、如果都没有左右子树，返回true

****\******\******\******\******\*****

判断左右子树是否对称相等

1. 如果node1不等于node2的值val，return false
2. 如果node1有左子树时
   - 如果node2有右子树；递归判断node2的左右子树是否对称相等 ；否则返回false
3. 同理与2相反
4. 如果node2有左右节点；return false 否则返回true（ 到了这一步，node1必然是左右节点均为null）

```
// 如果有左子树

//如果node1不等于node2的值val，return false

//1、如果node1有左子树时
//2、如果node2有右子树；递归 ；否则返回false

//同理与1、2相反

//如果node2有左右节点；return false

public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        if(pRoot==null){
            return true;
        }
        //如果左右子树都存在
        if(pRoot.left!=null&&pRoot.right!=null){
            return JudNodeEque(pRoot.left,pRoot.right);
        }
        if(pRoot.left==null&&pRoot.right==null)
        //判断左右子树的是对称相等
        return true;
        return false;
    }
    public boolean JudNodeEque(TreeNode node1,TreeNode node2){
        
        //如果node1!=node2的值val，return false
        if(node1.val!=node2.val){
            return  false;
        }
        //1、如果node1有左子树时
        //2、如果node2有右子树；递归 ；否则返回false
        if(node1.left!=null){
            if(node2.right!=null){
                return JudNodeEque(node1.left,node2.right);
            }else{
                return false;
            }
        }
        //同理与1、2相反
        if(node1.right!=null){
            if(node2.left!=null){
                return JudNodeEque(node1.right,node2.left);
            }else{
                return false;
            }
        }
        // 到了这一步，node1必然是左右节点均为null
        if(node2.left!=null||node2.right!=null){
            return false;
        }
        //如果node2有左右节点；return false
        return true;
        
    }
  
}

```

#### 49 Z序遍历

描述

给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替） 例如： 给定的二叉树是{1,2,3,#,#,4,5} ![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05) 该二叉树之字形层序遍历的结果是

[[1],[3,2],[4,5]]

示例1

输入：

```
{1,2,3,#,#,4,5}
```

返回值：

```
[[1],[3,2],[4,5]]
```

##### 分隔符判断奇偶层

```
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if(pRoot==null){
            return new ArrayList<ArrayList<Integer> >();
        }
        //层序遍历
        LinkedList<TreeNode> list = new LinkedList();
        ArrayList<ArrayList<Integer> > array = new ArrayList();
        //压入分隔符null
        list.addFirst(null);
        //根节点压入队列
        list.addFirst(pRoot);
        //设置标志left-right = true
        boolean left_right = true;
        //队列size不为1时，跳出循环
        TreeNode temp;
        ArrayList<Integer> a = new ArrayList();
        
        while(list.size()>1||a.size()!=0){//调试后加a.size()!=0
            //如果left-right = true
            if(left_right){
                if(list.getFirst()!=null){
                    //从左到有元素弹出
                    temp = list.removeFirst();
                    a.add(temp.val);
                    //孩子节点进入队列
                    if(temp.left!=null){
                        list.addLast(temp.left);
                    }
                    if(temp.right!=null){
                        list.addLast(temp.right);
                    }
                }else{
                    left_right = false;
                    ArrayList a_copy = (ArrayList) a.clone();
                    array.add(a_copy);
                    a.clear();
                    continue;
                }
                //如果right - left = false
            }

            if(!left_right){
                if(list.getLast()!=null){
                    //从左到有元素弹出
                    temp = list.removeLast();
                    a.add(temp.val);
                    //孩子节点进入队列
                    if(temp.right!=null){
                        list.addFirst(temp.right);
                    }
                    if(temp.left!=null){
                        list.addFirst(temp.left);
                    }
                    
                }else{
                    ArrayList a_copy = (ArrayList) a.clone();
                    array.add(a_copy);
                    a.clear();
                    left_right = true;
                }
            }
        }
       
        return array;
    }
}
```

##### 奇偶数队列

```
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if(pRoot==null){
            return new ArrayList<ArrayList<Integer> >();
        }
        //层序遍历
        LinkedList<TreeNode> listOdd = new LinkedList();
        LinkedList<TreeNode> listEven = new LinkedList();
        ArrayList<ArrayList<Integer> > array = new ArrayList();

        //根节点压入奇数队列
        listOdd.addFirst(pRoot);
        //设置标志left-right = true
        boolean left_right = true;
        //两个队列size==0时，跳出循环
        TreeNode temp;
        ArrayList<Integer> a = new ArrayList();
        while(listOdd.size()>0||listEven.size()>0){
            //如果left-right = true
            if(left_right){
                //如果奇数队列size()!=0
                if(listOdd.size()>0){
                    //从左到右元素弹出
                    temp = listOdd.removeFirst();
                    a.add(temp.val);
                    //孩子节点进入偶数队列
                    if(temp.left!=null){
                        listEven.addLast(temp.left);
                    }
                    if(temp.right!=null){
                        listEven.addLast(temp.right);
                    }
                    //若奇队列空了，则将数组储存
                    if (listOdd.size()<=0){
                        ArrayList a_copy = (ArrayList) a.clone();
                        array.add(a_copy);
                        a.clear();
                        left_right = !left_right;
                    }
                }
                //如果right - left = false
            }

            if(!left_right){
                //如果偶数队列size！==0
                if(listEven.size()>0){
                    //从右到左元素弹出
                    temp = listEven.removeLast();
                    a.add(temp.val);
                    //孩子节点进入奇数队列
                    if(temp.right!=null){
                        listOdd.addFirst(temp.right);
                    }
                    if(temp.left!=null){
                        listOdd.addFirst(temp.left);
                    }
                    //若奇队列空了，则将数组储存
                    if (listEven.size()<=0){
                        ArrayList a_copy = (ArrayList) a.clone();
                        array.add(a_copy);
                        a.clear();
                        left_right = !left_right;
                    }
                }
            }

        }

        return array;
    }
}
```

#### 50**把二叉树打印成多行**

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

例如： 给定的二叉树是{1,2,3,#,#,4,5} ![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05) 该二叉树多行打印层序遍历的结果是

[[1],[2,3],[4,5]]

示例1

输入：

```
{1,2,3,#,#,4,5}
```

返回值：

```
[[1],[2,3],[4,5]]
```

##### 两组队列交替执行

```
import java.util.*;


/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if(pRoot==null){
            return new ArrayList();
        }
        ArrayList<ArrayList<Integer> > array = new ArrayList();
        ArrayList<Integer> a ;
        Queue<TreeNode> nodes1 = new LinkedList();
        Queue<TreeNode> nodes2 = new LinkedList();
        nodes1.add(pRoot);
        TreeNode temp;
        boolean node = true;
        while(nodes1.size()!=0||nodes2.size()!=0){
            a = new ArrayList();
            while(node&&nodes1.size()!=0){
                temp = nodes1.poll();
                a.add(temp.val);
                if(temp.left!=null){
                    nodes2.add(temp.left);
                }
                if(temp.right!=null){
                    nodes2.add(temp.right);
                }
            }
             while(!node&&nodes2.size()!=0){
                temp = nodes2.poll();
                a.add(temp.val);
                if(temp.left!=null){
                    nodes1.add(temp.left);
                }
                if(temp.right!=null){
                    nodes1.add(temp.right);
                }
            }
            node = !node;
            if(a.size()!=0){
                array.add(a);
            }
            
            
        } 
        return array;
    }
    
}
```

## 51-60

#### 51 序列化二叉树

二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。

二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

##### 层序遍历

序列化： 直接利用层序遍历 但注意数字与数字之间需要进行划分，本题用”_“分割，否则反序列化时无法辨识多为数字

反序列化： 同样是层序遍历的思想 创建首节点并添加到队列 然后为队列弹出的元素添加结点，添加结点的同时这些结点进行入队操作 特别注意字符”串“转化成数字的情况：0-9 转化简单，但是大于一位数需要重新定义函数考虑

```


import java.util.*;
public class Solution {
    String Serialize(TreeNode root) {
        if(root==null){
            return "";
        }
        //直接利用层序遍历
        //注意数字与数字之间需要进行划分，本题用”_“分割，否则反序列化时无法辨识多为数字
        Queue<TreeNode> qu = new LinkedList();
        String s = "";
        qu.add(root);
        TreeNode temp = new TreeNode(root.val);
        s = s + temp.val;
        while(qu.size()!=0){
            temp = qu.poll();
            if(temp.left!=null){
                qu.add(temp.left);
                s = s +'_'+ temp.left.val;
            }else{
                s = s +'_'+"#";
            }
            if(temp.right!=null){
                qu.add(temp.right);
                s = s +'_'+ temp.right.val;
            }else{
                s = s +'_'+ "#";
            }
        }
        return s;

    }
    TreeNode Deserialize(String str) {
        if(str.length()==0){
            return null;
        }
        
        //同样是层序遍历的思想
        //为队列弹出的元素添加结点
        //特别注意字符”串“转化成数字的情况
        //0-9 转化简单，但是大于一位数需要重新定义函数考虑
        
        //双指针TreeNodetemp int ba
        String[] cs = str.split("_");

        TreeNode temp;
        int br = 0;
        TreeNode proot = new TreeNode(StringToint(cs[br]));
        Queue<TreeNode> qu = new LinkedList();

        qu.add(proot);
        while(br<cs.length&&qu.size()!=0){
            //while(ba<str.length()){
            //if(ba指向元素不是#)，temp增加左结点；qu入队新节点；ba++
            temp = qu.poll();
            br++;
            if(br<cs.length&&!cs[br].equals("#")){
                temp.left = new TreeNode(StringToint(cs[br]));
                qu.add(temp.left);
            }
            //if(ba指向元素不是#)，temp增加右结点；qu入队新节点；ba++
            br++;
            if(br<cs.length&&!cs[br].equals("#")){
                temp.right = new TreeNode(StringToint(cs[br]));
                qu.add(temp.right);
            }
            //

        }
        return proot;
    }
    //字符转化成字符串
    int StringToint(String s){
        char[] cs = s.toCharArray();
        int a = 0;
        for (int i = 0; i<cs.length; i++){
            a = a * 10 + (cs[i]-'0');
        }
        return a;
    }
}
```

#### 52 二叉搜索树的第k个结点

给定一棵二叉搜索树，请找出其中的第k小的TreeNode结点。

示例1

输入：

```
{5,3,7,2,4,6,8},3
```

返回值：

```
4//按结点数值大小顺序第三小结点的值为4 
```

##### 前序遍历之后排序

```
import java.util.*;
public class Solution {
    TreeNode KthNode(TreeNode pRoot, int k) {
        if(k-1>=0){
            k = k-1;
        }else{
            return null;
        }
        ArrayList<TreeNode> array = new ArrayList();//存储结点

        ArrayList<Integer> a = new ArrayList();//存储结点数值

        PerEg(pRoot, array, a);//前序遍历

        ArrayList<Integer> index = (ArrayList)a.clone();//存储结点索引便于找到结点索引
        a.sort(null);//比较器相关知识 Collections.sort(a);
        if(a.size()>k){
            TreeNode t = array.get(index.indexOf(a.get(k)));
            return t;
        }else{
            return null;
        }
    }
    void PerEg(TreeNode node, ArrayList<TreeNode> array, ArrayList<Integer> a){
        if(node!=null){
            array.add(node);
            a.add(node.val);
        }else{
            return ;
        }
        PerEg(node.left, array, a);
        PerEg(node.right, array, a);

        return ;
    }

}
```

##### 中序遍历

不要忘记二叉树的性质，中序遍历的顺序就是从小到大的顺序

```
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    TreeNode KthNode(TreeNode pRoot, int k) {
        if(k-1>=0){
            k = k-1;
        }else{
            return null;
        }
        ArrayList<TreeNode> array = new ArrayList();//存储结点

        PerEg(pRoot, array);//中序遍历

        if(array.size()>k){
            return array.get(k);
        }else{
            return null;
        }
    }
    void PerEg(TreeNode node, ArrayList<TreeNode> array){
        
        if(node==null){
            return;
        }
        PerEg(node.left, array);
        array.add(node);
        PerEg(node.right, array);
        return ;
    }
}
```

#### 53 旋转数组的最小数

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

输入：

```
[3,4,5,1,2]
```

返回值：1

##### 二分法

采用二分法解答这个问题，

mid = low + (high - low)/2

需要考虑三种情况：

**(1)array[mid] > array[high]:**

出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。

low = mid + 1

**(2)array[mid] == array[high]:**

左边右边分别计算，取最小值

**(3)array[mid] < array[high]:**

出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左

边。因为右边必然都是递增的。

high = mid

```
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0){
            return 0;
        }

        return minBiny(0,array.length-1 ,array);
    }
    public int minBiny(int low, int high, int[] array){

        int mid = (low + high)/2;
        //if(mid)
        if(array[mid]<array[high]){
            if(mid<=low){
                return array[mid];
            }
            return minBiny(low,mid,array);
        }
        if(array[mid]>array[high]){
            if(mid<=low){
                return array[high];
            }
            return minBiny(mid,high,array);
        }
        
        if(mid<=low){
            return array[mid];
        }
        int minA = minBiny(low,mid,array);
        int minB = minBiny(mid,high,array);

        return Math.min(minA,minB);
    }
}
```

##### **优化**

**(2)array[mid] == array[high]:**

出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边

还是右边,这时只好一个一个试 ，

high = high - 1



```
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0){
            return 0;
        }

        return minBiny(0,array.length-1 ,array);
    }
    public int minBiny(int low, int high, int[] array){

        int mid = (low + high)/2;
        //if(mid)
        if(array[mid]<array[high]){
            if(mid<=low){
                return array[mid];
            }
            return minBiny(low,mid,array);
        }
        if(array[mid]>array[high]){
            if(mid<=low){
                return array[high];
            }
            return minBiny(mid,high,array);
        }
        high = high - 1;
        
        return minBiny(low, high, array);
    }
}
```

##### 进一步优化

```
import java.util.*;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length == 0){
            return 0;
        }
        int first = 0;
        int last = array.length-1;
        int mid = 0;
        while(last>first){
            mid = first+(last-first)/2;
            if(array[first]<array[last]){
                return array[first];
            }else if(array[mid]<array[last]){
                last = mid;
            }else if(array[mid]>array[last]){
                first = mid+1;
            }else{
                last--;
            }
        }
        return array[first];
    }
}
```



#### 54 数字在升序数组中出现的次数

统计一个数字在升序数组中出现的次数。

示例1

输入：

```
[1,2,3,3,3,3,4,5],3
```

返回值：4

##### 三次二分

```

public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        int first = 0;
        int last = array.length-1;
        int mid;
        //定位众数
        while(last>=first){
            mid = (first + last)/2;
            if(array[mid]>k){
                last = mid - 1;
            }else if(array[mid]<k){
                first = mid + 1;
            }else{
                return getNumber(first,last,array);
            }
        }
        return 0;
    }

    public int getNumber(int first,int last, int [] array){
        //从first - mid
        int mid = (first + last)/2;
        int k = array[mid];
        //if a[mid] = k；反之
        //直first>=mid
        int lastleft = mid;
        while(first < lastleft){
            mid = (first + lastleft)/2;
            //if a[mid]！=k；重数组临界重定位到左边 first = mid+1
            if(array[mid] != k){
                first = mid + 1;
            }
            if(array[mid] == k){
                lastleft = mid - 1;
            }
        }
        int f = first;

        int firstright = mid;
        last = array.length - 1;
        while(firstright < last){
            mid = (firstright + last)/2;
            //if a[mid]！=k；重数组临界重定位到左边 first = mid+1
            if(array[mid] != k){
                last = mid - 1;
            }
            if(array[mid] == k){
                firstright = mid + 1;
            }
        }
        int l =last;
        return l-f+1;
    }
}
```

##### 两次二分

```
    /*
    思路：
    O(n)的肯定不行
    因为有序，所以想二分思想，O(logn)
    
    但是求出次数，不可能一次二分。
    根据观察，所求等于两个二分结果相减。
    
    而这两个数分别是大于(k-0.5)的第一个数，
    和大于(k+0.5)的第一个数。
    
    所以二分思想方法的语义就为：
    找到第一个大于浮点数m的下标。
    1.如果array[mid]>m，说明mid可能为所求。end = mid;
    2.如果array[mid]<m，说明mid不可能未所求。 start = mid+1
    3.不存在array[mid]=m，因为m为浮点数
    4.当start等于end就结束，不需要再求一次mid（求mid的话,最后结束不了）
    */
    public int GetNumberOfK(int [] array , int k) {
       //searchNum的语义是求第一个大于浮点数m的下标
       int a = searchNum(array,k-0.5);
       int b = searchNum(array,k+0.5);
       return b-a;
    }
    
    public int searchNum(int[] array ,double m){
        int start = 0,end = array.length;
        //这里start等于end就结束（不需要等于时再求mid）
        while(start < end){
            int mid = start + (end - start) / 2;
            //不会出现array[mid]等于m的情况，m是浮点数
            //当array[mid] > m时，这个mid下标满足所求
            if(array[mid] > m){
                end = mid;
            }else{
                //当array[mid] < m时，mid不为所求，舍去
                start = mid + 1;
            }
        }
        //start等于end
        return start;
    }
```

#### 55 子数组的最大累加和

给定一个数组arr，返回子数组的最大累加和

例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.

题目保证没有全为负数的数据

[要求]

时间复杂度为O(n)*O*(*n*)，空间复杂度为O(1)*O*(1)

思路：C[i]存储着**从i向前的最大和** 必须包含i

```
import java.util.*;


public class Solution {
    /**
     * max sum of the subarray
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxsumofSubarray (int[] arr) {
        if(arr.length==0){
            return 0;
        }
        // write code here
        int[] C = new int[arr.length];//C[i]存储着从i向前的最大和 必须包含i
        C[0] = arr[0];
        for(int i=1; i<arr.length; i++){
            if(C[i-1]>0){
                C[i] = C[i-1] + arr[i];
            }else{
                C[i] = arr[i];
            }
        }
        Arrays.sort(C);
        return C[C.length-1];
    }
}
```

##### 优化

```
import java.util.*;
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        //定义一个数组存储 从每个元素开始最大子数组和
        int[] maxsum = new int[array.length];
        int max = array[0];
        //遍历原数组
        maxsum[0] = max;
        for(int i=1; i<array.length; i++){
            if(maxsum[i-1]>0){
                maxsum[i] = maxsum[i-1] + array[i];
            }else{
                maxsum[i] = array[i];
            }
            max = Math.max(max,maxsum[i]);
        }
        //if前一个元素的max子元素和大于零，该点的元素max子数组和为 + 前一个元素的子数组和
        //否则取该位置的元素

        return max;
        //数组排序
    }
}
```



#### 56 最长公共子序列

给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

[(24条消息) 动态规划 最长公共子序列 过程图解*hrn1216的博客-CSDN博客*最长公共子序列](https://blog.csdn.net/hrn1216/article/details/51534607)

![img](file://D:/%E6%A1%8C%E9%9D%A2/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%A8%8B%E5%BA%8F%E7%8C%BF/%E7%AC%94%E8%AE%B0%E5%9B%BE%E5%BA%93/Center.jpeg?lastModify=1635319120)

```
import java.util.*;


public class Solution {
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        // write code here
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int[][] dp = new int[c1.length+1][c2.length+1];
        //初始化最长公共子序列
        for(int i = 0; i<c2.length+1; i++){
            dp[0][i] = 0;
        }
        for(int i = 1; i<c1.length+1; i++){
            dp[i][0] = 0;
        }
        //循环遍历判断c1 i行第一个元素与c2各元素的是否相等
        for(int i = 0; i<c1.length; i++){
            for(int j = 0; j<c2.length; j++){
                if(c1[i] == c2[j]){
                    dp[i+1][j+1] = dp[i][j]+1;
                    //相等则此处加一承接dp[i-1][j-1]
                }else{
                   
                    //不相等则取dp[i-1][j]和dp[i][j-1]中的最大值
                    if(dp[i][j+1] > dp[i+1][j]){
                           dp[i+1][j+1] = dp[i][j+1];
                    }else{
                        dp[i+1][j+1] = dp[i+1][j];
                    }
                }
            }
        }
        //从dp数据的最后一行最后一列算起
        int i = c1.length;
        int j = c2.length;
        String LSC = "";
        while(i>0&&j>0){
            //不相等则移动到dp[i-1][j]和dp[i][j-1]中的最大值
            if(c1[i-1] == c2[j-1]){
                LSC = c1[i-1] + LSC;
                i--;
                j--;
            }else{
                if(dp[i][j-1] > dp[i-1][j]){
                    j--;
                }else{
                    i--;
                }
            }
            //相等则记录字符向前递推
        }
        if(LSC.length()==0){
            return "-1";
        }
        return LSC;
     }
}
```

#### 57 最长子回文串

对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。

给定字符串**A**以及它的长度**n**，请返回最长回文子串的长度。

示例1

输入：

```
"abc1234321ab",12
```

返回值：

```
7
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



58 爬楼梯扩展问题

描述

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。

示例1

输入：

```
3
```

返回值：

```
4
```



递推公式

设f[i] 表示 当前跳道第 i 个台阶的方法数。那么f[n]就是所求答案。

假设现在已经跳到了第 n 个台阶，那么前一步可以从哪些台阶到达呢？

如果上一步跳 1 步到达第 n 个台阶，说明上一步在第 n-1 个台阶。已知跳到第n-1个台阶的方法数为f[n-1]

如果上一步跳 2 步到达第 n 个台阶，说明上一步在第 n-2 个台阶。已知跳到第n-2个台阶的方法数为f[n-2]

。。。

如果上一步跳 n 步到达第 n 个台阶，说明上一步在第 0 个台阶。已知跳到 第0个台阶的方法数为f[0]

那么总的方法数就是所有可能的和。也就是f[n] = f[n-1] + f[n-2] + ... + f[0]

显然初始条件f[0] = f[1] = 1

所以我们就可以先求f[2]，然后f[3]...f[n-1]， 最后f[n]

#### 59 字符流中第一个不重复的字符

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。

后台会用以下方式调用Insert 和 FirstAppearingOnce 函数

> string caseout = "";
>
> 1.读入测试用例字符串casein
>
> 2.如果对应语言有Init()函数的话，执行Init() 函数
>
> 3.循环遍历字符串里的每一个字符ch {
>
> Insert(ch);
>
> caseout += FirstAppearingOnce()
>
> }
>
> \2. 输出caseout，进行比较。

返回值描述：

如果当前字符流没有存在出现一次的字符，返回#字符。

示例1

输入：

```
"google"
```

复制

返回值："ggg#ll"

```

import java.util.*;
public class Solution {
    //Insert one char from stringstream
      //Insert one char from stringstream
    HashMap<Character, Boolean> hm=new HashMap();
    ArrayList<Character> list=new ArrayList<Character>();
    public void Insert(char ch)
    {
        if(hm.containsKey(ch)){
            hm.put(ch,true);
        }else{
            hm.put(ch,false);
        }
        list.add(ch);
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce()
    {
        for(char c :list){
            if(!hm.get(c))
                return c;
        }
        return '#';
    }
}
```

#### 60 设计最久未使用缓存结构

**描述**

设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 k，并有如下两个功能

1. set(key, value)：将记录(key, value)插入该结构
2. get(key)：返回key对应的value值

提示:

1.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的，然后都会刷新缓存。

2.当缓存的大小超过k时，移除最不经常使用的记录。

3.输入一个二维数组与k，二维数组每一维有2个或者3个数字，第1个数字为opt，第2，3个数字为key，value

若opt=1，接下来两个整数key, value，表示set(key, value) 若opt=2，接下来一个整数key，表示get(key)，若key未出现过或已被移除，则返回-1 对于每个opt=2，输出一个答案

4.为了方便区分缓存里key与value，下面说明的缓存里key用""号包裹

要求：set和get操作复杂度均为



```
import java.util.*;
public class Solution {
    /**
     * lru design
     * @param operators int整型二维数组 the ops
     * @param k int整型 the k
     * @return int整型一维数组
     */
    public int[] LRU (int[][] operators, int k) {
        //定义一个返回数组，一个缓存（链表记录最近未使用，hash记录key和val）
        ArrayList arr = new ArrayList();
        HashMap<Integer,Integer> hash = new HashMap();
        LinkedList<Integer> list = new LinkedList();
        //循环遍历操作数
        for(int i=0; i< operators.length; i++){
             //if op[0] == 1 执行set
            //if op[0] == 2 执行get
            if(operators[i][0]==1){
                set(operators[i][1], operators[i][2], list, hash, k);
            }
            if(operators[i][0]==2){
                arr.add(get(operators[i][1], list, hash));
            }
            
        }
        int[] a = new int[arr.size()];
        for(int i = 0; i<arr.size(); i++){
            a[i] = (Integer)arr.get(i);
        }
        return a;
    }
    
    public void set(int k, int v, LinkedList<Integer> list, HashMap<Integer,Integer> hash, int capacity){
        if(hash.containsKey(k)){
            list.remove((Integer) k);
        }else if(list.size()>=capacity){
            Integer a = list.removeFirst();
            hash.remove(a);
        }
         list.add(k);
         hash.put(k,v);
    }
    
    public int get(int k, LinkedList<Integer> list, HashMap<Integer,Integer> hash){
        if(hash.containsKey(k)){
            list.remove((Integer) k);
            list.add(k);
            return hash.get(k);
        }else{
             return -1;
        }
    }
}
```

## 61-70

#### 61 环形链表

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null&&fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast==slow){
                return true;
            }
            
        }
        
        return false;
    }
}
```



#### 62 二分查找

描述

请实现有重复数字的升序数组的二分查找

给定一个 元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的第一个出现的target，如果目标值存在返回下标，否则返回 -1

示例1

输入：

```
[1,2,4,4,5],4
```

返回值：

```
2
```

说明：

```
从左到右，查找到第1个为4的，下标为2，返回2 

```

##### 二分定位+向前遍历

```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        if(nums.length==0){
            return -1;
        }
        int first = 0;
        int last = nums.length-1;
        int mid = (first + last)/2;
        while(first<=last&& nums[mid]!=target){
            if(target>nums[mid]){
                first = mid+1;   //mid+1
             
            }else{
                last = mid-1;
                
            }
               mid = first + (last-first)/2;
        }
        
        if(nums[mid]!=target){
            return -1;
        }else{
            while(mid >= 0 && nums[mid]==target){
                mid--;
            }
            return mid+1;
        }
        
        // write code here
    }
}
```

##### 二分查汇

```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        if(nums.length==0){
            return -1;
        }
        int first = 0;
        int last = nums.length-1;
        int mid = (first + last)/2;
        int index = -1;
        while(first<=last){
            if(target>nums[mid]){
                first = mid+1;
            }else if(target<nums[mid]){
                last = mid-1;
            }else{         //可能不是第一个
                index = mid;
                last = mid - 1;
            }
               mid = first + (last-first)/2;
        }
        
        return index;
     
        // write code here
    }
}
```



#### 63 层序遍历

##### 用节点 数组分层

```
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型ArrayList<ArrayList<>>
     */
     ArrayList<ArrayList<Integer>> array = new ArrayList();
     ArrayList<ArrayList<TreeNode>> Nodes = new ArrayList();//存储节点的
    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        
        if(root==null){
            return array;
        }
        
        ArrayList listnode = new ArrayList();
        listnode.add(root);
        Nodes.add(listnode);
        int i = 0;
        while(i<Nodes.size()){
            layer(i);
            i++;
        }
        // write code here
        
        for(int m = 0; m<Nodes.size(); m++){//将Nodes的节点元素转化成数组元素
            ArrayList list = new ArrayList();
            for(int n = 0; n<Nodes.get(m).size();n++){
                list.add(Nodes.get(m).get(n).val);
            }
            array.add(list);
        }
               
        return array;
    }
    public void layer(int i){
        ArrayList list = new ArrayList();
        for(TreeNode node : Nodes.get(i)){
            if(node.left!=null){
                list.add(node.left);
            }
            if(node.right!=null){
                list.add(node.right);
            }
        }
        if(list.size()!=0){
             Nodes.add(list);
        }
    }
}
```

##### 递归思想

```
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @return int整型ArrayList<ArrayList<>>
     */
     ArrayList<ArrayList<Integer>> array = new ArrayList();
   
    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        
        if(root==null){
            return array;
        }
        layer(root,0);
      
        return array;
    }
    public void layer(TreeNode node,int leve){
        if(array.size()==leve){
            array.add(new ArrayList<Integer>());
        }
        ArrayList list = array.get(leve);
        list.add(node.val);
        if(node.left!=null){
            layer(node.left, leve+1);
        }
        if(node.right!=null){
            layer(node.right, leve+1);
        }
       
    }
}
```

#### 64 寻找最K大数

有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。

给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。

输入：

```
[1,3,5,2,2],5,3
```

返回值：

##### 快排+二分

```
public class Solution {
    public int findKth(int[] a, int n, int K) {
        // write code here
        return quicksearch(a,0,n-1,K ,n);

    }
    public int quicksearch(int[] a, int first, int last, int k ,int length){
        int temp1 = first+1;
        int temp2 = last;

        if(first>=last){ //递归边界
            if((length - first)==k){
                return a[first];
            }
            return -1;
        }
        while(true){ //关键
            //寻找a[i]小于首元素的 位置 用于交换
            while(a[temp2]>=a[first]){
                temp2--;
                if(temp2<=first){
                    break;
                }
            }
            //寻找a[i]大于首元素的 位置 用于交换
            while(a[temp1]<=a[first]){
                temp1++;
                if(temp1>=last){
                    break;
                }
            }

            if(temp1<temp2){
                exch(a,temp1,temp2);
            }else { //关键
                break;
            }

        }

        exch(a,temp2,first);

       //二分思想
        if((length - temp2)>k){
            return quicksearch(a,temp2+1,last,k,length);
        }
        if((length - temp2)==k){
            return a[temp2];
        }
        if((length - temp2)<k){

            return quicksearch(a,first,temp2-1,k,length);
        }

        return -1;
    }
    public void exch(int[] a, int temp1, int temp2){
        int s = a[temp1];
        a[temp1] = a[temp2];
        a[temp2] = s;
    }
}
```



#### 65 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

##### 两层遍历

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        for(int i = 0; i<nums.length; i++){
                for(int j = i+1; j<nums.length; j++){
                    if(nums[j]==(target-nums[i])){
                        result[0] = i;
                        result[1] = j;
                        return result;
                    }
                }
        }
        return result;

    }
}
```



##### Hash

```
import java.util.HashMap;
import java.util.Map;
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> hash = new HashMap<Integer,Integer>();
        int[] result = new int[2];
        //遍历数组
        for(int i = 0; i<nums.length; i++){  
            if(hash.containsKey(nums[i])){
                result[0] = i;
                result[1] = hash.get(nums[i]);
            }
            hash.put(target-nums[i],i);//必须在后面 防止 该位置元素＋自己等于target的情况

        }
        return result;

        //将每个数组的补数（target-num）存储到hash中

        //判断这个数key是否在hash中，在的话返回键和值

    }
}
```

#### 66 两数相加

给你两个 非空 的**链表**，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数**相加**，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。



##### 补齐相加

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //补齐链表
        lengthadd(l1,l2);
        //逐一累加注意进位 //
        return add(l1,l2);
    }

    public void lengthadd(ListNode node1, ListNode node2){

        while(node1.next!=null&&node2.next!=null){
            node1 = node1.next;
            node2 = node2.next;
        }
        if(node1.next==null){
            while(node2.next!=null){
                node1.next = new ListNode(0);
                node1 = node1.next;
                node2 = node2.next;
            }
        }else{
            while(node1.next!=null){
                node2.next = new ListNode(0);
                node1 = node1.next;
                node2 = node2.next;
            }
        }
    }

    public ListNode add(ListNode node1, ListNode node2){
        ListNode nodesum = new ListNode(0);
        ListNode temp = nodesum;
        int flag = 0;
        int sum = 0;
        while(node1!=null&&node2!=null){
            sum = node1.val+node2.val+flag;
            if(sum<10){
                temp.next = new ListNode(sum);
                flag = 0;
            }else{
                temp.next = new ListNode(sum%10);
                flag = 1;
            }
            temp = temp.next;
            node1 = node1.next;
            node2 = node2.next;
        }
        //最后一位进位的情况
        if (flag==1){
            temp.next = new ListNode(1);
        }
        return nodesum.next;
    }
}
```

##### 非补齐相加

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode root = new ListNode(0);
        ListNode cursor = root;
        int carry = 0;
        while(l1 != null || l2 != null || carry != 0) {
            int l1Val = l1 != null ? l1.val : 0;
            int l2Val = l2 != null ? l2.val : 0;
            int sumVal = l1Val + l2Val + carry;
            carry = sumVal / 10;
            
            ListNode sumNode = new ListNode(sumVal % 10);
            cursor.next = sumNode;
            cursor = sumNode;
            
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
        }
        return root.next;
    }
}
```



#### 67 无重复字串长度

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

##### 暴力解法

遍历每个字符往后最长无重复字串，并记录

```
import java.util.HashMap;

class Solution {
    public int lengthOfLongestSubstring(String s) {
        //两层for
        if(s.length()==0){
            return 0;
        }

        int MaxLength = 1;
        int count = 1 ;
        HashMap<Character,Object> hash;

        //第一层for记录以该元素开头，非重复字符串最大长度
        for(int i = 0; i<s.length(); i++){
            hash = new HashMap();
            hash.put(s.charAt(i),null);
            
            for(int j = i+1; j<s.length() ; j++){
                if(hash.containsKey(s.charAt(j))){
                    break;
                }
                hash.put(s.charAt(j),null);//被忘记
                count++;
            }
            //如果遇到重复字符或者遍历到头
            MaxLength = Math.max(MaxLength,count);
            count = 1;
        }
        return MaxLength;
    }
}
```

##### 滑动窗口

```
import java.util.HashMap;

class Solution {
    public int lengthOfLongestSubstring(String s) {
        //两层for
        if(s.length()==0){
            return 0;
        }

        int MaxLength = 1;
        int count = 1 ;
        HashMap<Character,Integer> hash;
        int first = 0;
        int last = first+1;
        //直到窗口到达s.length(),停止循环
        while(last<s.length()){
            hash = new HashMap();
            hash.put(s.charAt(first),first);
            while(last<s.length()&&!hash.containsKey(s.charAt(last))){
                hash.put(s.charAt(last),last);
                last++;
                count++;
            }
            MaxLength = Math.max(MaxLength,count);
          //窗口滑到最后
            if(!(last<s.length())){
                return MaxLength;
            }
            
            count = 1;
            //遇到重复字符更新窗口初始位置
            first = hash.get(s.charAt(last))+1;
            last = first+1;
        }   
        return MaxLength;
    }
}
```

##### 滑动窗口优化

```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 记录字符上一次出现的位置
        int[] last = new int[128];
        for(int i = 0; i < 128; i++) {
            last[i] = -1;
        }
        int n = s.length();

        int res = 0;
        int start = 0; // 窗口开始位置
        for(int i = 0; i < n; i++) {
            int index = s.charAt(i);
            //这一步巧妙的运用了last[]+1,在非重复情况下等于0；不重复情况下大于0的性质
            //遇到串前重复的，会因start较大而被忽略；
            start = Math.max(start, last[index] + 1);
            
            res   = Math.max(res, i - start + 1);
            last[index] = i;
        }

        return res;
    }
}
```

#### 68 两个有序数组的中位数

return (double)(array[ **array.length/2** ]+array[ **(array.length-1)/2** ] )/2;

**可以表示所有中位数**奇数偶数均可

##### 合并+sort 暴力解法

```
import java.util.*;
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] array =  new int[nums1.length + nums2.length];
        for(int i = 0 ; i<nums1.length ; i++){
            array[i] = nums1[i];
        }
        for(int i = 0 ; i<nums2.length ; i++){
            array[nums1.length+i] = nums2[i];
        }
        Arrays.sort(array);
        for(int i = 0 ;i<array.length; i++){
            System.out.println(array[i]);
        }
        if(array.length%2==0){
            return (double)(array[array.length/2]+array[array.length/2-1])/2;
        }

        return array[array.length/2];
    }
}
```

##### 归并思路

```
import java.util.*;
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] array =  new int[nums1.length + nums2.length];
        int temp1 = 0;
        int temp2 = 0;
        int i = 0 ;
        while(temp1<nums1.length&&temp2<nums2.length){
             if(nums1[temp1]<nums2[temp2]){
                array[i] = nums1[temp1];
                temp1++;
            }else{
                array[i] = nums2[temp2];
                temp2++;
            }
            i++;

        }
        while(temp1<nums1.length){
            array[i] = nums1[temp1];
            temp1++;
            i++;
        }
        while(temp2<nums2.length){
            array[i] = nums2[temp2];
            temp2++;
            i++;
        }
        for(int j = 0; j<array.length; j++){
            System.out.println(array[j]);
        }
        if(array.length%2==0){
            return (double)(array[array.length/2]+array[array.length/2-1])/2;
        }

        return array[array.length/2];
    }
}
```



#### 69 最长回文子串

##### 中心扩散 逐个判断 hash存储

```
import java.util.*;
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<=1){
            return s;
        }
        char[] cs = s.toCharArray();
        int maxLength = 1;
        int countLength ;
        HashMap<Integer, String> hash = new HashMap();

        for(int i = 1; i<cs.length; i++){
            int left = i-1;
            int right = i+1;
            String ss = ""+cs[i];
            countLength = 1;
            //从第二个字符开始，字符两边 定义两个指针 最长字串长度为1
            //如果指向字的符和起始字符相等 则指针移动 字串长度+1
            while(left>=0&&cs[left]==cs[i]){
                ss = cs[left] + ss;
                countLength++;
                left--;
            }
            while(right<cs.length&&cs[right]==cs[i]){

                ss = ss + cs[right];
                right++;
                countLength++;
            }
            //如果左右两个指针指向字符相等那么继续扩散 指针移动 子串长度+2;否则直接break
            while(left>=0&&right<cs.length){
                if(cs[left]==cs[right]){
                    countLength = countLength + 2;
                    ss = cs[right] + ss + cs[right];
                }else {
                    break;
                }
                left--;
                right++;
            }
            //比较是否为 最大长度
            if(maxLength<=countLength){
                maxLength = countLength;
                hash.put(maxLength,ss);
            }
            //长度为键 字串为值保存在hash中
        }
        return hash.get(maxLength);
    }
}
```

边界条件优化

```
import java.util.*;
class Solution {
    public String longestPalindrome(String s) {
        
        char[] cs = s.toCharArray();
        int maxLength = 1;
        int countLength ;
        HashMap<Integer, String> hash = new HashMap();

        for(int i = 0; i<cs.length; i++){
            int left = i-1;
            int right = i+1;
            String ss = ""+cs[i];
            countLength = 1;
            //从第二个字符开始，字符两边 定义两个指针 最长字串长度为1
            //如果指向字的符和起始字符相等 则指针移动 字串长度+1
            while(left>=0&&cs[left]==cs[i]){
                ss = cs[left] + ss;
                countLength++;
                left--;
            }
            while(right<cs.length&&cs[right]==cs[i]){

                ss = ss + cs[right];
                right++;
                countLength++;
            }
            //如果左右两个指针指向字符相等那么继续扩散 指针移动 子串长度+2;否则直接break
            while(left>=0&&right<cs.length){
                if(cs[left]==cs[right]){
                    countLength = countLength + 2;
                    ss = cs[right] + ss + cs[right];
                }else {
                    break;
                }
                left--;
                right++;
            }
            //比较是否为 最大长度
            if(maxLength<=countLength){
                maxLength = countLength;
                hash.put(maxLength,ss);
            }
            //长度为键 字串为值保存在hash中
        }
        return hash.get(maxLength);
    }
}
```

##### 中心扩散 分帧定界

```
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<=1){
            return s;
        }
        char[] cs = s.toCharArray();
        int maxLength = 1;
        int countLength ;
        int star = 0;
        int fina = 0;


        for(int i = 0; i<cs.length; i++){
            int left = i-1;
            int right = i+1;

            countLength = 1;

            //从首字符开始，字符两边 定义两个指针 最长字串长度为1
            //如果指向字的符和起始字符相等 则指针移动 字串长度+1
            while(left>=0&&cs[left]==cs[i]){
                countLength++;
                left--;
            }
            while(right<=cs.length-1&&cs[right]==cs[i]){
                right++;
                countLength++;
            }
            //如果左右两个指针指向字符相等那么继续扩散 指针移动 子串长度+2;否则直接break
            while(left>=0&&right<=cs.length-1){
                if(cs[left]==cs[right]){
                    countLength = countLength + 2;

                }else {
                    break;
                }
                left--;
                right++;
            }
            //比较是否为 最大长度 记录首尾位置
            if(maxLength<countLength){
                maxLength = countLength;
                star = left+1;
                fina = right-1;

            }
          
        }
        return s.substring(star,fina+1); //左开右闭合

    }
}
```

##### 动态规划

```
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    //对于长度为2的
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}

```

#### 70 整数反转

##### 队列输入输出

```
import java.util.*;
class Solution {
    public int reverse(int x) {
        //设置符号标志位
        boolean flag = false;
        LinkedList<Integer> stack = new LinkedList();
        int y = 0;
        int add = 0;
        if(x<0){
            flag = true;
        }
        //取绝对值
        x = Math.abs(x);
        //循环%10入栈，x = x/10 当x！=0时循环
        while(x!=0){
            stack.add(x%10);
            x /= 10; 
        }

        //出栈y = 出栈元素*10+y 栈不为空时循环
        while(stack.size()!=0){
            add = stack.poll();
            if((Integer.MAX_VALUE/10<y||(Integer.MAX_VALUE==y)&&(Integer.MAX_VALUE%10<add))||(Integer.MIN_VALUE/10>y||(Integer.MAX_VALUE==y)&&(Integer.MAX_VALUE%10>add))){
                return 0;
            }
            if(flag){
                y = y*10 - add;
            }else{
                y = y*10 + add;
            }
        }
        return y;
        //每次计算前判断溢出情况
    }
}
```

##### 不设置标志

```
import java.util.*;
class Solution {
    public int reverse(int x) {
   
        LinkedList<Integer> stack = new LinkedList();
        int y = 0;
        int add = 0;
   
        //循环%10入栈，x = x/10 当x！=0时循环
        while(x!=0){
            stack.add(x%10);
            x /= 10; 
        }
        //出栈y = 出栈元素*10+y 栈不为空时循环
        while(stack.size()!=0){
            add = stack.poll();
            if((Integer.MAX_VALUE/10<y||(Integer.MAX_VALUE==y)&&(Integer.MAX_VALUE%10<add))||(Integer.MIN_VALUE/10>y||(Integer.MAX_VALUE==y)&&(Integer.MAX_VALUE%10>add))){
                return 0;
            }
        
            y = y*10 + add;
            
        }
        return y;
        //每次计算前判断溢出情况
    }
}
```

##### 不借助数据结构

```

class Solution {
    public int reverse(int x) {
     
        int y = 0;
        int add = 0;
        while(x!=0){
            if((Integer.MAX_VALUE/10<y||(Integer.MAX_VALUE==y)&&(Integer.MAX_VALUE%10<add))||(Integer.MIN_VALUE/10>y||(Integer.MAX_VALUE==y)&&(Integer.MAX_VALUE%10>add))){
                return 0;
            }
            add = x%10;
            x /= 10;
            y = y*10 + add;
        }  
        return y;
        //每次计算前判断溢出情况
    }
}
```

## 71-80

#### 71 字符串Z型输出

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P   A   H   N A P L S I I G Y   I   R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);

##### 行数组按序存储

```
import java.util.*;
class Solution {
    public String convert(String s, int numRows) {
        if(numRows<=1){
            return s;
        }
        
        //创建一个Arraylist，记录每一行的字符
        ArrayList<String> rowstring = new ArrayList();
        for(int i = 0; i<numRows; i++){
            rowstring.add("");
        }

        //遍历字符串
        //创建一个标志位用于记录反转;一个计数器
        boolean flag = false;
        int count = 0;
        for(int i = 0;i<s.length(); i++){
            //正序遍历情况
            if(!flag||count==0){ //针对numRow==2的情况此时不存在逆行遍历
                rowstring.set(count,rowstring.get(count)+s.charAt(i));
                count++;
                if(count>=numRows){
                    flag = !flag;
                    //需要重置count用于反向遍历
                    count = numRows-2;
                }
            }else{
                
            //反向便利情况
                rowstring.set(count,rowstring.get(count)+s.charAt(i));
                count--;
                if(count<=0){
                    flag = !flag;
                }
            }
        }

        String ss = "";
        for(String t : rowstring){
            ss = ss + t;
        }
        return ss;
    }
}
```

##### 优化

```
import java.util.*;
class Solution {
    public String convert(String s, int numRows) {
        if(numRows<=1){
            return s;
        }
        
        //创建一个Arraylist，记录每一行的字符
        ArrayList<String> rowstring = new ArrayList();
        for(int i = 0; i<numRows; i++){
            rowstring.add("");
        }

        //遍历字符串
        //创建一个标志位用于记录反转;一个计数器
        boolean flag = false;
        int count = 0;
        for(int i = 0;i<s.length(); i++){
            //正序遍历情况
            if(!flag){ 
                rowstring.set(count,rowstring.get(count)+s.charAt(i));
                count++;
                if(count>=numRows-1){
                    flag = !flag;
                }
            }else{
            //反向便利情况
                rowstring.set(count,rowstring.get(count)+s.charAt(i));
                count--;
                if(count<=0){
                    flag = !flag;
                }
            }
        }

        String ss = "";
        for(String t : rowstring){
            ss = ss + t;
        }
        return ss;
    }
}
```

##### StringBuffer加速

```
import java.util.*;
class Solution {
    public String convert(String s, int numRows) {
        if(numRows<=1){
            return s;
        }
        
        //创建一个Arraylist，记录每一行的字符
        ArrayList<StringBuffer> rowstring = new ArrayList();
        for(int i = 0; i<numRows; i++){
            rowstring.add(new StringBuffer());
        }

        //遍历字符串
        //创建一个标志位用于记录反转;一个计数器
        boolean flag = false;
        int count = 0;
        for(char i : s.toCharArray()){
            //行字符拼接
            rowstring.set(count,rowstring.get(count).append(i));
            //正序遍历情况
            if(!flag){ 
                count++;
                if(count>=numRows-1) flag = !flag;
            }else{
            //反向便利情况
                count--;
                if(count<=0) flag = !flag;
            }
        }

        StringBuffer ss = new StringBuffer();
        for(StringBuffer t : rowstring){
            ss = ss.append(t);
        }
        return ss.toString();
    }
}
```



#### 72 字符转化成数子

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

1. 读入字符串并丢弃无用的前导空格
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具
6. 返回整数作为最终结果。

注意：

本题中的空白字符只包括空格字符 ' ' 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。



```
class Solution {
    public int myAtoi(String s) {
        char[] cs = s.toCharArray();
        //定义一个标志 
        int flag = 1;
        int num = 0;
        int index = 0;
        int length = s.length();
        //遍历字符串去掉前导空格
        while(index<length && cs[index]==' '){
            index++;
        }
        //全都是空格
        if(index >= length){
            return 0;
        }
      
        if(cs[index] == '-'){  
            flag = -1;
            index++;
        }else if(cs[index] == '+'){
            index++;
        }
         
        while(index < length){
            if(cs[index] < '0'||cs[index] > '9') break;

            if((Integer.MAX_VALUE/10<num||(Integer.MAX_VALUE/10==num&&flag*(cs[index] - '0')>Integer.MAX_VALUE%10))) return Integer.MAX_VALUE;

           if((Integer.MIN_VALUE/10>num||(Integer.MIN_VALUE/10==num&&flag*(cs[index] - '0')<Integer.MIN_VALUE%10))) return Integer.MIN_VALUE;
            num = num*10 + flag*(cs[index] - '0');
            index++;

        }
        
        return num;
    }
}
```



#### 73 回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

##### String.equal/StringBuffer.reverse

String 重写了 equal，比较字符串的内容

StringBuffer没有

```
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0){
            return false;
        }
        Integer X = x;
        StringBuffer s = new StringBuffer(X.toString());
        return (X.toString()).equals(s.reverse().toString());
    }
}
```

##### 提取后一半数字

```
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0||(x % 10 == 0 && x != 0)){//最后一位是0的情况
            return false;
        }
        int reversenum = 0;
        int add = 0;
        while(reversenum < x){
            add = x % 10;
            x = x /10;
            reversenum = reversenum*10 + add;
        }
        if(reversenum == x){
            return true;
        }else if(reversenum > x && reversenum/10 == x){
            return true;
        }
        return false;
    }
}
```

##### 整数反转

```
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0){
            return false;
        }
        int srcx = x ;
        int reversenum = 0;
        int add = 0;
        while(x>0){
            add = x % 10;
            x = x /10;
            reversenum = reversenum*10 + add;
        }
        if(reversenum == srcx){
            return true;
        }
        return false;
    }
}
```



#### 74 盛水容器

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

 

示例 1：

![img](file://D:/%E6%A1%8C%E9%9D%A2/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%A8%8B%E5%BA%8F%E7%8C%BF/%E7%AC%94%E8%AE%B0%E5%9B%BE%E5%BA%93/question_11.jpg?lastModify=1635319120)

输入：[1,8,6,2,5,4,8,3,7] 输出：49  解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。



##### 暴力解法

```
import java.util.*;
class Solution {
    public int maxArea(int[] height) {
        int[] maxArea = new int[height.length];
        for(int i = 0; i<height.length ; i++){
            maxArea[i] = maxWorter(i,height);
        }
        Arrays.sort(maxArea);
        return maxArea[maxArea.length-1];
    }

    public int maxWorter(int i, int[] height){
        int maxArea = 0;
        int maxH = 0;
        int curArea;
        //从数组末尾开始到i结束开始遍历 记录maxH 和 maxArea
        for(int j = height.length-1; j>i ; j--){
             //遇到更大的H计算Area，若为更大的Area
            if(height[j]>maxH){
                curArea = Math.min(height[i],height[j]) * (j-i);
                if(curArea>maxArea){           
                //更新maxArea和maxH
                    maxH = height[j];
                    maxArea = curArea;
                }
            }
            //超时优化 如果当前的最大max大于当前height[i] 
            //则有后续的不需要计算，必小
            if(height[i]<=maxH){
                break;
            }
        }
        return maxArea;
      
    }
}
```

##### 双指针

```
import java.util.*;
class Solution {
    public int maxArea(int[] height) {
        int maxArea = 0;
        //定义前后指针left right
        int left = 0;
        int right = height.length-1;
        int curArea;
        //判断指针指向高度并计算其大小
        while(left<right){
        //比较是个否大于maxArea，大于则更新
            curArea = Math.min(height[left],height[right]) * (right-left);
            if(curArea>maxArea){
                maxArea = curArea;
            }
            if(height[left] > height[right]) {
                right--;
            }else{
                left++;
            }     
        //移动高度较小值的指针;直到指针相遇
        }
        return maxArea;
    }

}
```



#### 75 数转换罗马

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值 I             1 V             5 X             10 L             50 C             100 D             500 M             1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。

##### 循环减法

```
class Solution {
    public String intToRoman(int num) {
        int[] number = {3000,2000,1000,900,500,400,100,90,50,40,10,9,5,4,1};
        String[] number_s = {"MMM","MM","M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
        StringBuffer result = new StringBuffer();
        
        for(int i = 0; i<number.length; i++){
            if(num<=0){
                return result.toString();
            }
            while(num>=number[i]){
                result.append(number_s[i]);
                num -= number[i];
            }
        }
        return result.toString();
    }
}
```



#### 76 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1：

输入：strs = ["flower","flow","flight"] 输出："fl" 示例 2：

输入：strs e ["dog","racecar","car"] 输出："" 解释：输入不存在公共前缀。

##### 指针遍历

```
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length == 1){
            return strs[0];
        }
        int temp = 0;
        int count = 0;
        String result = "";

        while(true){
            //指针移动
            while(count < strs.length-1){
                //利用异常结束字符串指针越界的情况
                try{
                        if(strs[count].charAt(temp) == strs[count+1].charAt(temp)){
                        count++;
                    }else{
                        return result;
                    }
                }catch(Exception e){
                    return result;
                }
                
            }
            result += strs[count].charAt(temp);
            count = 0;
            temp++;
        }

       // return result;
        
    }
}
```

##### 优化

```
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int length = strs.length;
        if(length == 1){
            return strs[0];
        }
        char c;
        String result = "";
        int indexMax = strs[0].length();

        for(int i = 0; i< indexMax ; i++){
            c = strs[0].charAt(i);//指针移动
            for(int j = 1; j<length; j++ ){
                if(i>=strs[j].length() ||strs[j].charAt(i)!=c){
                    return result;
                }
            }
            result += c;
        }
        return result;    
    }
}
```



##### 横向计算

两个字符串比较 得出结果再与第三个字符比较

```
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int length = strs.length;
        if(length == 1){
            return strs[0];
        }
        String result = strs[0];
        for(int i = 1; i<length ;i++){
            result = longestCommonPrefix(result,strs[i]);
        }
       
        return result;    
    }
    //两个字符串比较
    public String longestCommonPrefix(String str1, String str2 ){
        String result = "";
        for(int i = 0; i<Math.min(str1.length(),str2.length()); i++){
            if(str1.charAt(i)!=str2.charAt(i)){
                return result;
            }
            result += str1.charAt(i);
        }
        return result;
    }
}
```



#### 77 罗马转数字



这题懂了就非常简单。首先建立一个HashMap来映射符号和值，然后对字符串从左到右来，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。以此类推到最左边的数，最终得到的结果即是答案

##### 罗马数字规律 小减大加

```
import java.util.*;
class Solution {
    public int romanToInt(String s) {
        
        HashMap<Character,Integer> hash = new HashMap();
        hash.put('M',1000);
        hash.put('D',500);
        hash.put('C',100);
        hash.put('L',50);
        hash.put('X',10);
        hash.put('V',5);
        hash.put('I',1);
        int result = hash.get(s.charAt(s.length()-1));
       
        for(int i = 0; i<s.length()-1;i++){
            if(hash.get(s.charAt(i))>=hash.get(s.charAt(i+1))){
                    result = result + hash.get(s.charAt(i));
            }else{
                    result = result - hash.get(s.charAt(i));
            }
        }
        return result;

    }
}

```

##### replace

```
class Solution {
    public int romanToInt(String s) {
        s = s.replace("IV","a");
        s = s.replace("IX","b");
        s = s.replace("XL","c");
        s = s.replace("XC","d");
        s = s.replace("CD","e");
        s = s.replace("CM","f");
        
        int result = 0;
        for (int i=0; i<s.length(); i++) {
            result += which(s.charAt(i));
        }
        return result;
    }

    public int which(char ch) {
        switch(ch) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            case 'a': return 4;
            case 'b': return 9;
            case 'c': return 40;
            case 'd': return 90;
            case 'e': return 400;
            case 'f': return 900;
        }
        return 0;
    }
}
```



#### 78 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]]

##### 排序+3for+相邻元素去重

超时算法

```
import java.util.*;
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        if(nums.length<3){
            return new ArrayList();
        }
        Arrays.sort(nums);
        ArrayList<ArrayList<Integer>> array = new ArrayList();
        ArrayList a;
    
        //三层for指针
        for(int i = 0; i<nums.length-2; i++){
            if((i>0)&&(nums[i] == nums[i-1])) continue;
            for(int j = i+1; j<nums.length-1; j++){
                if((j>i+1)&&(nums[j] == nums[j-1])) continue;
                for(int k = j+1; k<nums.length ;k++){
                    if((k>j+1)&&(nums[k] == nums[k-1])) continue;
                    if((nums[i] + nums[j] + nums[k]) == 0){
                        a = new ArrayList();
                        a.add(nums[i]);
                        a.add(nums[j]);
                        a.add(nums[k]);
                        array.add(a);
                    }
                }
            }
        }
        return (List)array;

    }
}
```

##### 排序 固定 双指针

```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {// 总时间复杂度：O(n^2)
        List<List<Integer>> ans = new ArrayList<>();
        if (nums == null || nums.length <= 2) return ans;

        Arrays.sort(nums); // O(nlogn)

        for (int i = 0; i < nums.length - 2; i++) { // O(n^2)
            if (nums[i] > 0) break; // 第一个数大于 0，后面的数都比它大，肯定不成立了
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 去掉重复情况
            int target = -nums[i];
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                if (nums[left] + nums[right] == target) {
                    ans.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                    
                    // 现在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3
                    left++; right--; // 首先无论如何先要进行加减操作
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } else if (nums[left] + nums[right] < target) {
                    left++;
                } else {  // nums[left] + nums[right] > target
                    right--;
                }
            }
        }
        return ans;
    }
}
import java.util.*;
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        if(nums.length<3){
            return new ArrayList();
        }
        Arrays.sort(nums);
        ArrayList<ArrayList<Integer>> array = new ArrayList();
        ArrayList a;

        //双指针
        int target;
        for(int i = 0; i<nums.length-2; i++){
            if((i>0)&&(nums[i] == nums[i-1])) continue;
            //固定
            target = -nums[i];
            //双指针
            int left = i+1;
            int right = nums.length-1;
            while(right > left){
        
                if(( nums[left] + nums[right]) == target ){
                    a = new ArrayList();
                    a.add(nums[i]);
                    a.add(nums[left]);
                    a.add(nums[right]);
                    array.add(a);
                    left++;
                    right--;
                    //去重
                    while(right > left&&(nums[left] == nums[left-1]))left++;
                    while(right > left&&(nums[right] == nums[right+1])) right--;
                }else if(( nums[left] + nums[right]) > target){
                    right--;
                }else{
                    left ++;
                }
            }
        }

        return (List)array;
    }
}
```



#### 79 电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

输入：digits = "23" 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]



##### 数组+递归

数组1存放前组合

数组2存放当前数字表征的字符

两层for遍历数组1数组2进行组合

得到数组3用于后续递归

```
import java.util.*;
class Solution {
    public List<String> letterCombinations(String digits) {
        if(digits.length()==0){
            return new LinkedList();
        }
   
        //数字对应的第i个字符 char =(digit - '0' -2) *3 +'a' +i;
        char[] cs = digits.toCharArray();
        //创建一个队列存储第一个数字代表的字符
        List<String> list = new LinkedList();
        list.add("");
      
        return letterCombinations(list ,cs, 0);

    }

    public List<Character> numberTochars(char number) {
        List<Character> list = new LinkedList();
        if(number<='6'){
            for(int i = 0; i<3; i++){
                list.add( (char)((number - '0' - 2)*3 + 'a' +i) );
            }
        }
        if(number == '7'){
            list.add('p');
            list.add('q');
            list.add('r');
            list.add('s');
        }
        if(number == '8'){
            list.add('t');
            list.add('u');
            list.add('v');
        }
        if(number == '9'){
            list.add('w');
            list.add('x');
            list.add('y');
            list.add('z');
        }

        return list;
    }
    public List<String> letterCombinations(List<String> List, char[] cs, int i){
        if(!(i<cs.length)){
            return List;
        }
        List<String> result = new LinkedList();
        //下一个字符队列
        List<Character> temp = numberTochars(cs[i]);
        //开始拼接
        for(Character c : temp){
            for(String s : List ){
                result.add(s+c);
            }
        }
        return letterCombinations(result,cs,i+1);
    }
}
```

队列思想

```
import java.util.*;
class Solution {
    public List<String> letterCombinations(String digits) {
        if(digits.length()==0){
            return new LinkedList();
        }
   
        //数字对应的第i个字符 char =(digit - '0' -2) *3 +'a' +i;
        char[] cs = digits.toCharArray();
        //创建一个队列存储第一个数字代表的字符
        LinkedList<String> list = new LinkedList();
        list.add("");
      
        return letterCombinations(list ,cs, 0);

    }

    public List<Character> numberTochars(char number) {
        List<Character> list = new LinkedList();
        if(number<='6'){
            for(int i = 0; i<3; i++){
                list.add( (char)((number - '0' - 2)*3 + 'a' +i) );
            }
        }
        if(number == '7'){
            list.add('p');
            list.add('q');
            list.add('r');
            list.add('s');
        }
        if(number == '8'){
            list.add('t');
            list.add('u');
            list.add('v');
        }
        if(number == '9'){
            list.add('w');
            list.add('x');
            list.add('y');
            list.add('z');
        }

        return list;
    }
    public LinkedList<String> letterCombinations(LinkedList<String> List, char[] cs, int i){
        if(!(i<cs.length)){
            return List;
        }
        String s;

        //下一个数字字符对应的字符队列
        List<Character> temp = numberTochars(cs[i]);
        
        //开始拼接
        //记录字符串长度 用于循环边界
        int length_src = List.get(0).length();
        while(true){
            //原组合弹出一个字符串，与下一个数字字符对应的字符队列，进行拼接
            s = List.poll();
            for(Character c : temp){
                List.add(s + c);
            }
            
            //如果到达了本次拼接出现的字符，（字符长度+1）字符拼接结束
            if(List.get(0).length()>length_src) break;

        }
 
        return letterCombinations(List,cs,i+1);
    }
}

```

##### 深度优先搜索

```
import java.util.*;
class Solution {
    List<String> result  = new ArrayList();
    String[] numbers_strings = { "","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    public List<String> letterCombinations(String digits) {
        if(digits.length()==0){
            return result;
        }
        DFS(digits,0,"");
        return result;
    }
     public void DFS(String digits,int index, String combination){
        //当前分支达到数字字符串末尾，将拼接结果加入result
        if(!(index < digits.length())){
            result.add(combination);
            return;
        }
        //遍历当前索引字符串与上一个组合进行拼接
        int number = digits.charAt(index)-'0';
        String number_string = numbers_strings[number];
        for(int i = 0; i<number_string.length(); i++){
            DFS(digits,index+1,combination + number_string.charAt(i));
        }
    }
    
}
   
```

![image-20211013111458173](file://D:/%E6%A1%8C%E9%9D%A2/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%A8%8B%E5%BA%8F%E7%8C%BF/%E7%AC%94%E8%AE%B0%E5%9B%BE%E5%BA%93/image-20211013111458173.png?lastModify=1635319120)

```
package leetcode._17;

import java.util.ArrayList;
import java.util.List;

public class Solution17_1 {

    private String letterMap[] = {
            " ",    //0
            "",     //1
            "abc",  //2
            "def",  //3
            "ghi",  //4
            "jkl",  //5
            "mno",  //6
            "pqrs", //7
            "tuv",  //8
            "wxyz"  //9
    };

    private ArrayList<String> res;

    public List<String> letterCombinations(String digits) {

        res = new ArrayList<String>();
        if(digits.equals(""))
            return res;

        findCombination(digits, 0, "");
        return res;
    }

    private void findCombination(String digits, int index, String s){

        if(index == digits.length()){
            res.add(s);
            return;
        }

        Character c = digits.charAt(index);
        String letters = letterMap[c - '0'];
        for(int i = 0 ; i < letters.length() ; i ++){
            findCombination(digits, index+1, s + letters.charAt(i));
        }

        return;
    }

}


```

#### 80 删除倒数第n个节点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：**你能尝试使用一趟扫描实现吗？

##### 遍两次次

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //遍历字符串长度
        int length = 0;
        ListNode temp = head;
        while(temp!=null){
            length++;
            temp = temp.next;
        }
        int count = length - n +1;
        if(count <= 1){
            return head.next;
        }
        temp = head;
        int i = 1;
        while(i!=count-1){
            temp = temp.next;
            i++;
        }
        temp.next = temp.next.next;
        return head;
    }
}
```

##### 数组储存遍历一次

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    ArrayList<ListNode> arrayList = new ArrayList();
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //遍历字符串长度
        int length = 0;
        ListNode temp = head;
        while(temp!=null){
            arrayList.add(temp);
            length++;
            temp = temp.next;
        }
        int count = length - n ;//删除的索引
        if(count <= 0){//与上一个程序不同的地方
            return head.next;
        }
        arrayList.get(count - 1).next = arrayList.get(count).next;
        return head;
    }
}
```

##### 双指针

计算**倒数**相关的方法：

1. **两个指针在初始位置**
2. **一个指针移动n步，然后两个指针同时移动**，至前指针到达末尾

```
/*
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    ArrayList<ListNode> arrayList = new ArrayList();
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode H = new ListNode();
        H.next = head;
        ListNode tempF = H;
        ListNode tempB = H;
        
        for(int i = 0; i<n; i++){
            tempF = tempF.next;
        }
        
        while(tempF.next != null){
            tempF = tempF.next;
            tempB = tempB.next;
        }
        
        tempB.next = tempB.next.next;
        return H.next;
    }
}
```



## 81-90

### 81 有效括号

```
class Solution {
    public boolean isValid(String s) {
        char[] cs = s.toCharArray();
        //利用hash记录 括号对
        HashMap<Character,Character>  CharMap = new HashMap(); 
        Stack<Character> stack = new Stack();
        CharMap.put('(',')');
        CharMap.put('[',']');
        CharMap.put('{','}');
        for(int i = 0; i<cs.length; i++ ){
            //逐个压入字符
            //如果压入的字符与当前栈顶的字符匹配，则出栈
            if(!stack.empty()){
                if(cs[i]==CharMap.get(stack.peek())){
                    stack.pop();
                    continue;
                    //否则 如果hash没有的key的话，直接返回false
                }else if(!CharMap.containsKey(cs[i])){
                    return false;
                }
            }
            //如果 当前字符在hash中 则压栈,或者栈为空且在
            if(!CharMap.containsKey(cs[i]))
                return false;
             stack.push(cs[i]);
         
        }
        //最后看情况堆栈中是否有值，无则ture
         if(!stack.empty()) return false;
         return true;
    }
}
```



### 82 合并有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例 1：

输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2：

输入：l1 = [], l2 = [] 输出：[]

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //一个头节点head，和指向它的指针
        ListNode head = new ListNode();
        ListNode temp = head;
        //比较两节点大小
        ListNode temp1 = l1;
        ListNode temp2 = l2;
        //指针1指向的节点 小或者等指针二指向的节点
        while(temp1!=null&&temp2!=null){
  //指针1指向的节点，连接到头节点，指针一后移，头结点指针后移，并next指向null
            if(temp1.val<temp2.val){
                temp.next = temp1;
                temp1 = temp1.next;
            }else{
                temp.next = temp2;
                temp2 = temp2.next;
            }
             temp = temp.next;
                //temp.next = null;
        }
        // temp.next = (temp1 != null ? temp1 : temp2);
        if(temp1!=null){
            temp.next = temp1;
        }
        if(temp2!=null){
            temp.next = temp2;
        }
        //否则操作指针2
        //返回头节点。next
        return head.next;

    }
}
```

### 83 合并多个有序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

#### 逐一合并

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode head = null;
        for(int i = 0; i<lists.length; i++){
            head = mergeLists(head,lists[i]);
        }
        return head;

    }
    public ListNode mergeLists(ListNode list1,ListNode list2){
        ListNode head = new ListNode();
        ListNode temph = head;
        ListNode temp1 = list1;
        ListNode temp2 = list2;
        while(temp1!=null&temp2!=null){
            if(temp1.val > temp2.val){
                temph.next = temp2;
                temp2 = temp2.next;
            }else{
                temph.next = temp1;
                temp1 = temp1.next;
            } 
            temph = temph.next;
        }
        
 // temp.next = (temp1 != null ? temp1 : temp2);
        if(temp1!=null){
            temph.next = temp1;
          
        }
        if(temp2!=null){
            temph.next = temp2;
        }
        return head.next;
    }
}
```

#### 归并排序

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0){
            return null;
        }

       return sort(lists, 0, lists.length-1);

    }

    public ListNode sort(ListNode[] lists, int first, int last)
    {

        if(first>=last){
            return lists[first];//关键
        }
        int mid = (first+last)>>1;
        ListNode temp1 = sort(lists,first, mid);
        ListNode temp2 = sort(lists,mid+1,last);
        return mergeLists(temp1,temp2);
    }

    public ListNode mergeLists(ListNode list1,ListNode list2){
        ListNode head = new ListNode();
        ListNode temph = head;
        ListNode temp1 = list1;
        ListNode temp2 = list2;
        while(temp1!=null&temp2!=null){
            if(temp1.val > temp2.val){
                temph.next = temp2;
                temp2 = temp2.next;
            }else{
                temph.next = temp1;
                temp1 = temp1.next;
            } 
            temph = temph.next;
        }

        while(temp1!=null){
            temph.next = temp1;
            temp1 = temp1.next;
            temph = temph.next;
        }
        while(temp2!=null){
            temph.next = temp2;
            temp2 = temp2.next;
            temph = temph.next;
        }
        return head.next;
    }
}
```

### 84 删除有序数据中重复项

返回前k个不同数据 长度K

#### 双指针

```
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length<=1){
            return nums.length;
        }
        int front = 0;
        int after = 1;
        while(after<nums.length){
            if(!(nums[after]==nums[after-1])){
                nums[++front] = nums[after];
            } 
            after++;  
        }
        return front+1;

    }
}
```

### 85 实现strStr()

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

#### substring

找到起始索引相同的，用substring，注意越界异常

```
class Solution {
    public int strStr(String haystack, String needle) {
        int length_ne = needle.length();
        int length_ha = haystack.length();
        if(length_ne==0){   
            return 0;  
        }
        int temp1 = 0;
       
        while(temp1<length_ha&&(temp1+length_ne-1)<length_ha){
            if((haystack.charAt(temp1)==needle.charAt(0))){
                if(haystack.substring(temp1,temp1+length_ne).equals(needle)) return temp1;
            }
            temp1++;
        }
        return -1;
        
    }
}
```

#### 循环遍历

思路类似

```
class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), m = needle.length();
        for (int i = 0; i + m <= n; i++) {
            boolean flag = true;
            for (int j = 0; j < m; j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return i;
            }
        }
        return -1;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution {

  public int strStr(String haystack, String needle) {

    return haystack.indexOf(needle);

}

}
```



### 86 旋转有序数组搜索

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4

#### 二分法

去中间值，判断中值边界值的大小关系，有序二分，无序递归

```
class Solution {
    public int search(int[] nums, int target) {
        int front = 0;
        int end = nums.length - 1;

        return subsearch(nums,target,front,end);
    }

    public int subsearch(int[] nums, int target, int front, int end){
        int res = -1;
        if(front==end){
            if(nums[end]==target){
                return end;
            }
            return res;
        }
        int mid = (front+end)>>1;

        //前一半判断
        if(nums[front] <= nums[mid]){
            //有序
            res = Binary(nums,target,front,mid);

        }else{
            //无序
            res = subsearch(nums,target,front,mid);
        }
//判断是否已经得出结果
        if(res!=-1){
            return res;
        }

        //后一半判断

        if(nums[mid+1] <= nums[end]){
            res = Binary(nums,target,mid+1,end);
        }else{
            res = subsearch(nums,target,mid+1,end);
        }

        return res;

    }
    public int Binary(int[] nums, int target ,int front, int end){
        if(target<nums[front]||target>nums[end]||front>end){
            return -1;
        }
        int mid = (front+end)>>1;
        if(nums[mid]>target){
            return Binary(nums,target,front,mid-1);//mid-1
        }else if(nums[mid]<target){
            return Binary(nums,target,mid+1,end);//mid+1
        }
        return mid;
    }
}
```

#### 二分法简介

```
class Solution {
    public int search(int[] nums, int target) {
        int front = 0;
        int end = nums.length - 1;
        int mid ;
        //边界条件front>end
        while(front<=end){
            //中值是否为目标值？
            mid = (front+end)>>1;
            if(nums[mid]==target){
                return mid;
            }
            //是返回mid
            if(nums[front]<=nums[mid])//等号
            //判断前一半是否有序
            {
                //判断目标值是否在这个区间
                if(nums[front]<=target&&target<=nums[mid]){
                    end = mid -1;
                }else{
                    front = mid+1;
                }
                //在这个区间继续二分
                //不在这个区间另一半无序递归
            }else{
                if(nums[mid]<=target&&target<=nums[end]){
                    front = mid+1;
                }else{
                    end = mid -1;
                }
            }
            //后一半同理
        }
        return -1;
    }
}
```



### 87 有序数组找到某数的前后索引

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        //找到目标出现的第一个位置
        int temp = Binary(nums,target,0,nums.length-1);
        int index1 = temp;
        int index2 = temp;
        //目标位置向前找索引
        while(temp!=-1){
            temp = Binary(nums,target,0,index1-1);
            //更新索引
            if(temp!=-1){
                index1 = temp;
            }
        }
         //目标位置向后找索引
        temp = index2;
        while(temp!=-1){
            temp = Binary(nums,target,index2+1,nums.length-1);
            if(temp!=-1){
                index2 = temp;
            }
        }
        int[] res = {index1,index2};

        return res;
    }
    public int Binary(int[] nums, int target, int low, int high){
        if(low>high){
            return -1;
        }
        int mid = (low+high)>>1;
        if(nums[mid]>target){
            return Binary(nums,target,low,mid-1);

        }else if(nums[mid]<target){
            return Binary(nums,target,mid+1,high);

        }
        return mid;
        
    }
}
```

### 88 缺失的第一个正数

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

示例 1：

输入：nums = [1,2,0] 输出：3 示例 2：

输入：nums = [3,4,-1,1] 输出：2 示例 3：

输入：nums = [7,8,9,11,12] 输出：1



#### 排序+遍历

注意下重复数据

```
class Solution {
    public int firstMissingPositive(int[] nums) {
        Arrays.sort(nums);
        int minnum = 1;
        for(int i = 0; i<nums.length; i++){
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            if(nums[i]>0){
                if(nums[i]!=minnum){
                    return minnum;
                }
                minnum++;
            }
        }
        return minnum;

    }
}
```

#### Hash

```
import java.util.*;
class Solution {
    public int firstMissingPositive(int[] nums) {
        HashMap<Integer,Object> hash = new HashMap();
        for(int i = 0; i<nums.length; i++){
            hash.put(nums[i],null);
        }
        for(int i = 1; i<nums.length+2; i++){
            if(!hash.containsKey(i)){
                return i;
            }
        }
        return 1;
        
    }
}
```

#### 负数标记法

1. 不在范围内的置成N+1

2. 得到全部为正数的数组

3. 遍历数组元素取绝对值，若在范围内

   ​	判断以它为索引的数组是否被标记（负数）

   ```
   未标记则标记（将对应的数置成负数）
   ```

   ​		标记了，跳过

4. 遍历全部数组，如有正未标记的数直接输出索引

5. 输出N+1

```
class Solution {
    public int firstMissingPositive(int[] nums) {
        int nummax = nums.length + 1;
        int index = 0;
        //将不再范围的数重置
        for(int i = 0; i < nums.length; i++){
            if(nums[i]<1||nums[i]>nummax-1){
                nums[i] = nummax;
            }
        }
        //全部的数据均为正数，使用负号标记，绝对值判断
        for(int i = 0; i < nums.length; i++){
            index = Math.abs(nums[i]);
            //在范围内的数据
            if(index>0 && index<nummax){
                //未被标记的,进行标记 表示nums[i]数已经存在
                if(nums[index-1]>0){
                    nums[index-1] = -1*nums[index-1];
                }
            }
        }
        for(int i = 0; i < nums.length; i++){
            //非负的位置即结果
            if(nums[i]>=0){
                return i+1;
            }
        }
        return nummax;
    }
}
```

### 89 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：

输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：

输入：nums = [1] 输出：[[1]]

#### 递归

0-first-1表示已经排列的，将依次遍历后续元素，与first索引处的元素交换，每交换一次，first已经排列的 ；进入下一次递归；

```
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList();
        List<Integer> output = new ArrayList();
        int length = nums.length;
        for(int i = 0 ; i<length ; i++){
            output.add(nums[i]);
        }
        subpermute(res,output,0,length);
        return res;
    }
    public void subpermute(List<List<Integer>> res,List<Integer> output,int first,int n){
        if(first>=n){
            res.add(new ArrayList<Integer>(output));
            return;
        }
        for(int i = first; i<n ;i++){
            exch(output,first,i);
            subpermute(res,output,first+1,n);
            exch(output,first,i);
        }
    }
    public void exch(List<Integer> output,int i,int j ){
        int temp = output.get(i);
        output.set(i,output.get(j));
        output.set(j,temp);
    }
}
```



### 90 矩阵旋转

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

 

示例 1：

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]]

#### 模拟

matrix[j](#) = matrixcopy[i](#);

```
class Solution {
    public void rotate(int[][] matrix) {
        //行为原来的列；列为length-行
        
        int n = matrix.length;
        int[][] matrixcopy = new int[n][n];
        for(int i = 0; i<n; i++){
            for(int j = 0; j<n; j++){
                matrixcopy[i][j] = matrix[i][j];
            }
        }
        for(int i = 0; i<n; i++){
            for(int j = 0; j<n; j++){
                matrix[j][n-i-1] = matrixcopy[i][j];
            }
        }
    
    }
}
```

#### 先转置再镜像

注意转置和镜像操作的索引变化位置

```
class Solution {
    public void rotate(int[][] matrix) {
        //行为原来的列；列为length-行
        
        int n = matrix.length;
        int temp = 0;
        int first = 0;//用与转置遍历起始索引

        for(int i = 0; i<n; i++){
            for(int j = first; j<n; j++){
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
            first++;
        }
       
        int rn = n/2;
        for(int i = 0; i<n; i++){
            for(int j = 0; j<rn; j++){//按照列来的
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][n-j-1];
                matrix[i][n-j-1] = temp; 
            }
        }
    
    }
}
```

## 91-100

### 91 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次。

示例 1:

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"] 输出: [["bat"],["nat","tan"],["ate","eat","tea"]]



```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<Character,Integer> hashsrc = new HashMap();
        HashMap<Character,Integer> hashdig = new HashMap();
        List<List<String>> res = new ArrayList();

        for(int i = 0; i<strs.length; i++){
            ArrayList<String> array = new ArrayList();
            if(strs[i]!="X"){
                array.add(strs[i]);
                hashsrc = ToHash(strs[i]);   
                for(int j = i+1; j<strs.length; j++){
                    hashdig = ToHash(strs[j]);
                    if(hashequal(hashsrc,hashdig)){
                        array.add(new String(strs[j]));
                        strs[j] = "X";
                    }
               }
               res.add(array);
            }        
        }

        return res;

    }
    public HashMap<Character,Integer> ToHash(String str){
        HashMap<Character,Integer> hash = new HashMap();
        for(int i = 0; i<str.length(); i++){
            char c = str.charAt(i);
            if(!hash.containsKey(c)){
                hash.put(c,1);
            }else{
                hash.put(c,hash.get(c)+1);
            }
        }
        return hash;
    }

    public boolean hashequal(HashMap<Character,Integer> hash1,HashMap<Character,Integer> hash2){

        if(hash1.size() == hash2.size()){
            for(Character c : hash1.keySet()){
                if(hash2.containsKey(c)&&hash2.get(c)==hash1.get(c)){
                    continue;
                }else{
                    return false;
                }
            }

        }else{
            return false;
        }

        return true;
    }
}
```

#### 字符做索引

```java

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        int[] indexChar1 = new int[123];
        int[] indexChar2 = new int[123];
        List<List<String>> res = new ArrayList();
        ArrayList<String> output = new ArrayList();

        for(int i = 0; i<strs.length; i++){
            if(strs[i]==""){
                output.add(strs[i]);
                strs[i]="X";
            }
        }
        if(output.size()!=0)
            res.add(output);

        for(int i = 0; i<strs.length; i++){
            output = new ArrayList();
            if(strs[i]!="X"){
                indexChar1 = TocharIndexArray(strs[i]);
                output.add(strs[i]);
                for(int j = i+1; j<strs.length; j++){
                    if(strs[j]!="X"){
                        indexChar2 = TocharIndexArray(strs[j]);
                        if(Arrays.equals(indexChar1,indexChar2)){
                            output.add(new String(strs[j]));
                            strs[j] = "X";
                        }
                    }

                }
                res.add(new ArrayList(output));

            }
        }
        return res;
    }

    public int[] TocharIndexArray(String str){
        int[] indexChar = new int[123];
        int k;
        int index;
        for(int i = 0; i<str.length(); i++){
            k = indexChar[str.charAt(i)];
            index = str.charAt(i);
            indexChar[index] = ++k;
        }
        return indexChar;
    }
}
```

#### 排序字符串作键，字符串链表做值



```java
class Solution {
     public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, ArrayList<String>> map = new HashMap<>();
        for (int i = 0; i < strs.length ; i++) {
            char[] chars = strs[i].toCharArray();
            Arrays.sort(chars);
            String key = String.valueOf(chars);
            if (!map.containsKey(key)) {
                map.put(key, new ArrayList<>());
            }
            map.get(key).add(strs[i]);
        }
        return new ArrayList<>(map.values());
    }
}
```

### 92 pow()

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.2

#### 幂转化成2的幂加和

X^n 

这里n 可以做乘二进制形式;对应2^i 加和形式；i为n的第i个二进制位；

假设 n 二进制共 m位，则迭代计算 x的2^i 次幂；2 4  8 16 ...（容易计算：x = x*x;）

幂上面的加和 在底数上就是相乘；(迭代相乘X= X*x)



![image-20211027154435162](笔记图库/image-20211027154435162.png)

```java

class Solution {
    public double myPow(double x, int n) {
        long N = n;
        boolean flag = true;
        if(N<0){
            N = Math.abs(N);
            flag = false;
        }
        return flag ? Pow(x,N) : 1.0/Pow(x,N);
    }
    public double Pow(double x,long N){
        double X = 1;
        while(N!=0){
            //x开始平方迭代 得X
            //N与1& 如果等于1 累乘X 否则不乘
            if((N&1)==1){
                X = X * x;
            }
            x = x*x;
            N = N >> 1;
            //N>>1 直到N=0；
        }
        return X;
    }
}
```

### 93 最大子序列和

#### 动态规划

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==1){
            return nums[0];
        }
        int Maxsum = nums[0];
        int[] sum = new int[nums.length];
        sum[0] = Maxsum;
        for(int i = 1; i<nums.length; i++){
            if(sum[i-1]>0){
                sum[i] = nums[i] + sum[i-1];
            }else{
                sum[i] = nums[i];
            }
            Maxsum = Math.max(sum[i],Maxsum);
        }
        return Maxsum;
    }
}
```

#### **优化**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==1){
            return nums[0];
        }
        int Maxsum = nums[0];
        int per = 0;
        for(int i = 0; i<nums.length; i++){
            if(per>0){
                per = nums[i] + per;
            }else{
                per = nums[i];
            }
            Maxsum = Math.max(per,Maxsum);
        }
        return Maxsum;
    }
}
```

### 92 螺旋矩阵

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。


输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList();
        //定义上下边界top bottom 左右边界 left right
        int top = 0;
        int bottom = matrix.length-1;
        int left = 0;
        int right = matrix[0].length-1;
        //循环边界
        while(top<=bottom && left<=right){
            //横向一
            for(int i = left; i<=right; i++){
                list.add(matrix[top][i]);
            }
            top++;
            if(top>bottom){
                break;
            }
            //纵向二
            for(int i = top; i<=bottom; i++){
                list.add(matrix[i][right]);
            }
            right--;
            if(right<left){
                break;
            }
            //横向三
            for(int i = right; i>=left; i--){
                list.add(matrix[bottom][i]);
            }
            bottom--;
            if(top>bottom){
                break;
            }
            //纵向四
            for(int i = bottom; i>=top; i--){
                list.add(matrix[i][left]);
            }
            left++;
             if(right<left){
                break;
            }
        }
        return list;
    }
}
```



### 93 跳远可达

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。



#### 递归超时

```java
class Solution {
    public boolean canJump(int[] nums) {
        //循环
        int length = nums.length;
        return Jump(0,nums[0],nums,length);
    }

    public boolean Jump(int i, int number,int[] nums, int length){
        if(i == length-1){
            return true;
        }
        for(int step = 1; step<=number; step++){

            if(Jump( i+step , nums[i+step], nums, length)) return true;

        }
        return false;
    }
}
```

#### 贪心

在每个位置都计算一下最远可达距离，并记录当前最远可达距离

当遍历的位置大于 当前最远可达距离时 false；



```java
class Solution {
    public boolean canJump(int[] nums) {
       int maxstep = 0;
       for(int i = 0; i<nums.length; i++){
           if(i>maxstep){
               return false;
           }
           maxstep = Math.max(maxstep,nums[i]+i);
       }
       return true;
    }
}
```

#### 步步为营

从后向前，当前位置对于前面元素可达，则n = 1；前面的元素能（可达最远距离大于等于当前位置）到达当前位置即可；

对于前面元素不可达，则n++；需要后面元素为一的最大距离超过n

直到遍历到最后一个元素，此时n大于1 则不可达

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n=1;
        for(int i=nums.length-2;i>=0;i--){
            if(nums[i]>=n)
            {
                n=1;
            }
            else
            {
                n++;
            }
            if(i==0&&n>1)
            {
                return false;
            }
        }
        return true;
        
    }
}
```

### 94合并区间

#### 排序+合并

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].



合并注意是与当前结果集的最后一个数组进行比较

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        int right = 0;
        int left = 0;
        ArrayList<int[]> array = new ArrayList();
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] o1, int[] o2) {
               return o1[0] - o2[0]; }
        });
        array.add(intervals[0]);
        for(int i = 1; i<n; i++){
            right = array.get(array.size()-1)[1];
            //是否重叠
            if(intervals[i][0]<=right){
                //融合定界
                right = Math.max(right,intervals[i][1]);
                left = array.get(array.size()-1)[0];
                array.set(array.size()-1,new int[]{left,right});
            }else{
                array.add(intervals[i]);
            }
        }
        return array.toArray(new int[array.size()][]);
    }

```

### 95 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 示例 1：


输入：m = 3, n = 7
输出：28
示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
示例 3：

输入：m = 7, n = 3
输出：28
示例 4：

输入：m = 3, n = 3
输出：6



```java
class Solution {
    public int uniquePaths(int m, int n) {
        //动态规划
        int top = 0;
        int left = 0;

        //初始化
        int[][] grid = new int[m][n];
        grid[0][0] = 1; 
        for(int i = 0; i<m; i++){
            for(int j = 0; j<n; j++){
                //防止破坏初值
                if(i==0&&j==0) continue;
                top = i>0 ? grid[i-1][j] : 0;
                left = j>0 ? grid[i][j-1] : 0;
                grid[i][j] = top + left;
            }

        }
        return grid[m-1][n-1];

    }
}
```

### 96 整数加1

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1：

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。



```java
class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length-1;
        int carry = 0;
        int sum = 0;
        // +1
        sum = digits[n]+1+carry;
        carry = sum / 10;
        digits[n] = sum % 10;

        for(int i = n-1; i>=0; i--){         
            sum = digits[i]+carry;
            carry = sum / 10;
            digits[i] = sum % 10;

        }
        if(carry!=0){
            int[] res = new int[digits.length + 1];
            res[0] = carry;
            for(int i = 0; i<digits.length; i++){
                res[i+1] = digits[i];
            }
            return res;
        }
        return digits;
    }
}
```

### 97 pow()

平方根

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

示例 1：

输入：x = 4
输出：2

```java
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}

```

### 98 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

#### 递归超时

```java
class Solution {
    public int climbStairs(int n) {
        return f(n);
    }
    public int f(int n){
        if(n<0){
            return 0;
        }
        if(n == 1||n==0){
            return 1;
        }
        return f(n-1)+f(n-2);
    }
}
```

#### 动态规划

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i<=n; i++){
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```



### 99 矩阵置零

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

进阶：

一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个仅使用常量空间的解决方案吗？


示例 1：


输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]



#### 遍历0位置，hash储存，后置零

```java
import java.util.*;
class Solution {
    public void setZeroes(int[][] matrix) {
        HashMap<int[],Object> hash = new HashMap();
        for(int i = 0; i<matrix.length; i++){
            for(int j = 0; j<matrix[0].length; j++){
                if(matrix[i][j]==0){
                    hash.put(new int[]{i,j},null);
                }
            }
        }
        for(int[] coordinate: hash.keySet()){
            setZeroes(matrix, coordinate[0], coordinate[1]);
        }

    }

    public void setZeroes(int[][] matrix, int x,int y){
        for(int i = 0; i<matrix.length; i++){
            matrix[i][y] = 0;
        }
        for(int i = 0; i<matrix[0].length; i++){
            matrix[x][i] = 0;
        }
    }
}
```

### 100 颜色分类



#### 快排

```java
class Solution {
    public void sortColors(int[] nums) {
        sort(nums,0,nums.length-1);
    }
    public void sort(int[] nums, int front, int back){
        if(front>=back){
            return;
        }
        //定义双指针
        int first = front;
        int last = back;
        int division = nums[front];
        
        //根据首位元素 分两端段
        while(first<last){
            //先从后向前找小，停
            while(first<last&&nums[last]>=division){
                last--;
            } 
            //再从前向后找大，停
            while(first<last&&nums[first]<=division){
                first++;
            }
            //大小交换
            exch(nums,first,last);
            //相遇时 ,因为是 找小者 先移动最终相遇时 如果有小数一定相遇在此处
        }
        //如果相遇处是小数，则替换，否则不换
    
        exch(nums,front,first);

        sort(nums,front,first-1);
        sort(nums,last+1,back);
    }
    public void exch(int[] nums,int i ,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### 两次遍历

第一次遍历把0提前；

第二次遍历把1提前；

```java
class Solution {
    public void sortColors(int[] nums) {
        int last_0 = 0;
        for(int i = 0; i<nums.length; i++){
            if(nums[i] == 0){
                exch(nums,i,last_0);
                last_0++;
            }
        }
        int last_1 = last_0;
        for(int i = last_0; i<nums.length; i++){
            if(nums[i] == 1){
                exch(nums,i,last_1);
                last_1++;
            }
        }

    }
    public void exch(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### 双指针

```java
 class Solution {
    public void sortColors(int[] nums) {
        int last_0 = 0;
        int last_1 = 0;
        for(int i = 0; i<nums.length; i++){
            if(nums[i] == 0){
                exch(nums,i,last_0);
                //
                if(last_1>last_0){
                    exch(nums,i,last_1);
                }
                last_0++;
                last_1++;
            }else if( nums[i] == 1){
                exch(nums,i,last_1);
                last_1++;
            }
        }

    }
    public void exch(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## 101-110

### 101 最小覆盖字串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。


示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"



```java

class Solution {
    public String minWindow(String s, String t) {
        char[] ts = t.toCharArray();
        char[] ss = s.toCharArray();
        int n = ss.length;
        int minlength = Integer.MAX_VALUE;
        String res ="";
        //定义一个hash记录t的字符及其对应的个数
        HashMap<Character,Integer> hashchar = new HashMap();
        HashMap<Character,Integer> hashtemp = new HashMap();
        for(int i = 0; i<ts.length; i++){
            hashput(hashchar,ts[i]);
        }
        //定义双指针，遍历字符
        int left = 0;
        int right = 0;

        while(right<n){
            
            while(!cover(hashtemp,hashchar) && right < n){
                hashput(hashtemp,ss[right]);
                //x 右指针遍历字符数组，使用hashtemp记录遍历的字符数是否满足大于等于hash中的
                right++;
            }
            
            while(cover(hashtemp,hashchar) && left<n ){
                //左指针移动，更新hashtemp，当不满足覆盖字符串条件时，跳转至x
                hashremove(hashtemp,ss[left]);
                left++;
                
                 //满足条件，记录左右指针及其索引之差的最小值,更新结果，退出遍历
                if(!cover(hashtemp,hashchar)){
                    if((right-left+1)<minlength){
                        minlength = right-left+1;
                        //此时刚好删除了第一个包含字符 因此left -1
                        res = s.substring(left-1,right);
                    }
                    break;
                }
                
            }
            //等right到达n 时停止
        }
        return res;
    }

    public boolean cover(HashMap<Character,Integer> hashtemp,HashMap<Character,Integer> hashchar){
        for(Character i : hashchar.keySet()){
            if(hashtemp.containsKey(i)){
                if(hashtemp.get(i)<hashchar.get(i)){
                    return false;
                }
            }else{
                return false;
            }
        }
        return true;
    }
    
    public void hashput(HashMap<Character,Integer> hashchar, char c){
        if(hashchar.containsKey(c)){
            hashchar.put(c,hashchar.get(c)+1);
        }else{
            hashchar.put(c,1);
        }
    }
    
    public void hashremove(HashMap<Character,Integer> hashchar, char c){
        if(hashchar.containsKey(c)){
            if(hashchar.get(c)!=0){
                hashchar.put(c,hashchar.get(c)-1);
            }
        }else{
            throw new RuntimeException("remove 异常");
        }
    }
}
```

### 102 子集

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：

输入：nums = [0]
输出：[[],[0]]

#### 回溯递归

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new LinkedList();
        LinkedList list_i = new LinkedList();
        list.add(list_i);
        subsets(list,0,list_i,nums);
        return list;
    }

    public void subsets(List<List<Integer>> list, int first,List list_i,int[] nums){
        if(first>=nums.length) return;
        for(int i = first; i<nums.length; i++){
            List temp = new LinkedList(list_i); 
            temp.add(nums[i]);
            list.add(temp);
            subsets(list,i+1,temp,nums);
        }
    }
}
```

#### 二进制位

![image-20211101143115443](笔记图库/image-20211101143115443.png)

```java
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        for (int mask = 0; mask < (1 << n); ++mask) {
            t.clear();
            for (int i = 0; i < n; ++i) {
                if ((mask & (1 << i)) != 0) {
                    t.add(nums[i]);
                }
            }
            ans.add(new ArrayList<Integer>(t));
        }
        return ans;
    }
}
```

### 103 单词搜索

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

#### 第一个版

```java
import java.util.Arrays;

class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                if(exist(charcopy(board),word,i,j,0)) return true;
            }
        }
        return false;
    }

    public boolean exist(char[][] board, String word, int i, int j, int count){
        if(board[i][j]==word.charAt(count)){
            board[i][j] = ' ';
        }else{
            return false;
        }
        count++;
        while(count < word.length()){
            //查看前后左右
            if(i>0 && board[i-1][j]==word.charAt(count)){
                i = i-1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                //恢复
                board[i][j] = temp;
                i = i+1;
            }
            if(j>0 && board[i][j-1]==word.charAt(count)){

                j = j-1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                board[i][j] = temp;
                j = j+1;
            }
            if(j<board[0].length-1 && board[i][j+1]==word.charAt(count)){

                j = j+1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                board[i][j] = temp;
                j = j-1;
            }
            if(i<board.length-1 && board[i+1][j]==word.charAt(count)){

                i = i+1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                board[i][j] = temp;
                i = i-1;
            }
            return false;
        }
        return true;
    }
    //二维数组复制
    public char[][] charcopy(char[][] board){
        char[][] res = new char[board.length][];
        for(int i = 0; i<board.length; i++){
            res[i] = Arrays.copyOf(board[i],board[i].length);
        }
        return  res;
    }
}
```

#### 第二版

```java
import java.util.Arrays;
class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                if(exist(board,word,i,j,0)) return true;
            }
        }
        return false;
    }
    public boolean exist(char[][] board, String word, int i, int j, int count){
        if(!(board[i][j]==word.charAt(count))) return false;
        //用于数组恢复
        char C = board[i][j];
        board[i][j] = ' ';
        count++;

        if(count < word.length()){
            
            //查看前后左右
            if(i>0 && board[i-1][j]==word.charAt(count)){
                i = i-1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                //恢复
                board[i][j] = temp;
                i = i+1;
            }
            if(j>0 && board[i][j-1]==word.charAt(count)){
                j = j-1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                board[i][j] = temp;
                j = j+1;
            }
            if(j<board[0].length-1 && board[i][j+1]==word.charAt(count)){

                j = j+1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                board[i][j] = temp;
                j = j-1;
            }
            if(i<board.length-1 && board[i+1][j]==word.charAt(count)){
                i = i+1;
                char temp = board[i][j];
                if(exist(board,word,i,j,count)) return true;
                board[i][j] = temp;
                i = i-1;
            }
            
            board[i][j] = C;
            return false;
        }
        return true;
    }
}
```

#### 第三版

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                if(exist(board,word,i,j,0)) return true;
            }
        }
        return false;
    }
    public boolean exist(char[][] board, String word, int i, int j, int count){
        //边界
        if(!( i>=0&&j>=0&&j<=board[0].length-1&&i<=board.length-1 )) return false;
        if(!(board[i][j]==word.charAt(count))) return false;
        //用于数组恢复
        char C = board[i][j];
        board[i][j] = ' ';
        count++;
        if(count < word.length()){
            //查看前后左右
            if(exist(board,word,i-1,j,count)) return true;
            if(exist(board,word,i,j-1,count)) return true;
            if(exist(board,word,i,j+1,count)) return true;
            if(exist(board,word,i+1,j,count)) return true;
            board[i][j] = C;
            return false;
        }
        return true;
    }
}
```

#### 最终版

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                if(board[i][j]==word.charAt(0)){
                    if(exist(board,word,i,j,0)) return true;
                }
            }
        }
        return false;
    }

    public boolean exist(char[][] board, String word, int i, int j, int count){
        //用于数组恢复
        char C = board[i][j];
        board[i][j] = ' ';
        count++;
        if(count < word.length()){
            //查看前后左右
            if(i>0 && board[i-1][j]==word.charAt(count)){
                if(exist(board,word,i-1,j,count)) return true;
            }
            if(j>0 && board[i][j-1]==word.charAt(count)){
                if(exist(board,word,i,j-1,count)) return true;
            }
            if(j<board[0].length-1 && board[i][j+1]==word.charAt(count)){
                if(exist(board,word,i,j+1,count)) return true;
            }
            if(i<board.length-1 && board[i+1][j]==word.charAt(count)){
                if(exist(board,word,i+1,j,count)) return true;
            }
            board[i][j] = C;
            return false;
        }
        return true;
    }
}
```

### 104 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

#### 复制+双指针

```
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] nums3 = new int[0];
        for(int i = 0; i < m; i++){
            nums3 = Arrays.copyOf(nums1,m);
        }
        int temp3 = 0;
        int temp2 = 0;
        int temp1 = 0;
        while(temp3 < m && temp2 < n){
            if(nums2[temp2]<nums3[temp3]){
                nums1[temp1++] = nums2[temp2++];
            }else{
                nums1[temp1++] = nums3[temp3++];
            }
        }
        while(temp3 < m){
            nums1[temp1++] = nums3[temp3++];
        }
        while(temp2 < n){
            nums1[temp1++] = nums2[temp2++];
        }
    }
}
```



#### 逆向双指针

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int temp2 = n-1;
        int temp1 = m-1;
        int i = m + n -1;
        while(temp1>=0 && temp2>=0){
            if(nums1[temp1] > nums2[temp2]){
                nums1[i--] = nums1[temp1--];
            }else{
                nums1[i--] = nums2[temp2--];
            }
        }
        while(temp1 >= 0){
            nums1[i--] = nums1[temp1--];
        }
        while(temp2 >= 0){
            nums1[i--] = nums2[temp2--];
        }
    }
}
```

### 105 解码方法

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

示例 1：

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

#### 动态规划

![image-20211102085804764](笔记图库/image-20211102085804764.png)

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] f = new int[n+1];
        f[0] = 1;

        for(int i = 1; i<n+1; i++){
            if(s.charAt(i-1) != '0'){
                f[i] += f[i-1];
            }
            if(i>1 && s.charAt(i-2) != '0' && ((s.charAt(i-2)-'0')*10 +(s.charAt(i-1) - '0'))<=26){
                f[i] += f[i-2];
            }
        }
        return f[n];
    }
}
```

#### 进阶

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        // a = f[i-2], b = f[i-1], c=f[i]
        int a = 0, b = 1, c = 0;
        for (int i = 1; i <= n; ++i) {
            c = 0;
            if (s.charAt(i - 1) != '0') {
                c += b;
            }
            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) {
                c += a;
            }
            a = b;
            b = c;
        }
        return c;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/decode-ways/solution/jie-ma-fang-fa-by-leetcode-solution-p8np/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 106 中序遍历

二叉树的中序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        return midorder(root,new LinkedList<Integer>());
    }
    public List<Integer> midorder(TreeNode node , List<Integer> list){
        if(node == null) return list;
        if(node.left != null)midorder(node.left,list);
        list.add(node.val);
        if(node.right != null)midorder(node.right,list);
        return list;
    }   
}
```

### 107 验证二叉树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。


示例 1：


输入：root = [2,1,3]
输出：true



#### **中序遍历+验证正序**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    
    public boolean isValidBST(TreeNode root) {
        List<Integer> vals = new ArrayList();
        midDFS(root,vals);
        for(int i = 1; i<vals.size(); i++){
            if(!(vals.get(i)>vals.get(i-1))){
                return false;
            }
        }
        return true;
    }
    public void midDFS(TreeNode node,List<Integer> vals){
        if(node == null){
            return ;
        }
        if(node.left!=null) midDFS(node.left,vals);
        vals.add(node.val);
        if(node.right!=null) midDFS(node.right,vals);
    }
}
```

#### 优化

```java
class Solution {
    private long pre = Long.MIN_VALUE;

    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;

        boolean left = isValidBST(root.left);
        if (root.val <= pre) return false;
        pre = root.val;
        boolean right = isValidBST(root.right);

        return left && right;
    }
}
```

### 108 对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

   1

   / \
  2   2
 / \ / \
3  4 4  3


但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
  1
   / \
  2   2
   \   \
   3    3
```

#### 层序遍历+双指针

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    LinkedList<TreeNode> list = new LinkedList(); 
    LinkedList<TreeNode> listmetric = new LinkedList(); 
    public boolean isSymmetric(TreeNode root) {
        //list添加root
        list.add(root);
        //循环直到list为空
        while(list.size()!=0){
            for(TreeNode node : list){
                if(node!=null){
                    listmetric.add(node.left);
                    listmetric.add(node.right);
                }
            }
            if(!Listmetric(listmetric)) return false;
            list = new LinkedList(listmetric);
            listmetric.clear();
        //遍历list,左右节点插入listmetric
        //双指针遍历链表是否对称
        //不对称返回false
        //list = listmetric
        }
        return true;
    }
    public boolean Listmetric(LinkedList<TreeNode> list){
        int i = 0;
        int j = list.size()-1;
        while(i<j){
            if(list.get(i)!=null&&list.get(j)!=null){
                if(list.get(i).val!=list.get(j).val){
                    return false;
                }
            }else{
                if(!(list.get(i)==null&&list.get(j)==null)){
                    return false;
                }
            }
            i++;
            j--;
        }
        return true;

    }
}
```

#### 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root!=null){
            return subtreemetric(root.left,root.right);
        }
        return true;
    }
    public boolean subtreemetric(TreeNode node1, TreeNode node2){
        if(node1==null||node2==null){
            if(!(node1==null&&node2==null)){
                return false;
            }else{
                return true;
            }
        }
        if(node1.val!=node2.val){
            return false;
        }
        boolean i = subtreemetric(node1.left,node2.right);
        boolean j = subtreemetric(node1.right,node2.left);
        return i&&j;
    }
}



简化

class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root!=null){
            return subtreemetric(root.left,root.right);
        }
        return true;
    }
    public boolean subtreemetric(TreeNode node1, TreeNode node2){
        if(node1==null && node2==null) return true;
        if(node1==null || node2==null) return false;
        if(node1.val!=node2.val)return false;
        boolean i = subtreemetric(node1.left,node2.right);
        boolean j = subtreemetric(node1.right,node2.left);
        return i&&j;
    }
}
```

### 109 二叉树层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层序遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

#### 两个链表实现层序遍历

```java
class Solution {
    List<List<Integer>> res = new ArrayList();
    List<Integer> list = new ArrayList();
    List<TreeNode> list1 = new ArrayList();
    List<TreeNode> list2 = new ArrayList();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null){
            return res;
        }
        list1.add(root);
        while(list1.size()!=0){
            for(TreeNode node : list1){
                list.add(node.val);
                if(node.left!=null) list2.add(node.left);
                if(node.right!=null) list2.add(node.right);
            }
            res.add(new ArrayList(list));
            list1 = new ArrayList(list2);
            list.clear();
            list2.clear();
        }
        return res;
    }
}
```

#### size记录每一层的个数

```java
class Solution {
    List<List<Integer>> res = new LinkedList();
    List<Integer> list = new LinkedList();
    LinkedList<TreeNode> listNode = new LinkedList();
    int level_size = 0;
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null){
            return res;
        }
        TreeNode node;
        listNode.add(root);
        while(listNode.size()!=0){
            level_size = listNode.size();
            for(int i = 0; i<level_size; i++){
                node = listNode.poll();
                list.add(node.val);
                if(node.left!=null) listNode.add(node.left);
                if(node.right!=null) listNode.add(node.right);
            }
            res.add(new LinkedList(list));
            list.clear();
        }
        return res;
    }
}
```

### 110 Z遍历二叉树

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

​    3

   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：

[
  [3],
  [20,9],
  [15,7]
]

#### 双链表+数组反转

```java


class Solution {
     List<TreeNode> list1 = new ArrayList();
     List<TreeNode> list2 = new ArrayList();
    List<List<Integer>> res = new ArrayList();
    List<Integer> list = new ArrayList(); 
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root == null){
            return res;
        }
        list1.add(root);
        boolean flag_reverse = false;
        while(list1.size()!=0){
            for(TreeNode node : list1){
                list.add(node.val);
                if(node.left!=null) list2.add(node.left);
                if(node.right!=null) list2.add(node.right);
            }
            if(flag_reverse) Collections.reverse(list);
            res.add(new ArrayList(list));
            list1 = new ArrayList(list2);
            list.clear();
            list2.clear();
            flag_reverse = !flag_reverse;
        }
        return res;
    }
}
```



#### 队列

队列正序存储每层节点 但插入的方向和弹出的方向不同 奇数层 从前弹出，遍历左 右 节点并插入在队列后 偶数层 从后弹出，遍历 右 左节点 并插入在队列前

弹出的个数 由size每层的个数决定

```java
class Solution {
    LinkedList<TreeNode> listNode = new LinkedList();
    List<List<Integer>> res = new ArrayList();
    List<Integer> list = new ArrayList(); 
    int level_size = 0;
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
       if(root==null){
            return res;
        }
        TreeNode node;
        listNode.add(root);
        boolean flagReverse = false;
        while(listNode.size()!=0){
            level_size = listNode.size();
            for(int i = 0; i<level_size; i++){
                if(flagReverse){
                    node = listNode.removeLast();
                    list.add(node.val);
                    if(node.right!=null) listNode.push(node.right);
                    if(node.left!=null) listNode.push(node.left);
                }else{
                      node = listNode.pop();
                      list.add(node.val);
                      if(node.left!=null) listNode.add(node.left);
                      if(node.right!=null) listNode.add(node.right);
                }
            }
            res.add(new LinkedList(list));
            list.clear();
            flagReverse = !flagReverse;
        }
        return res;
    }
}
```

## 111-120

### 111 从前序与中序遍历序列构造二叉树

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点

Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

- 前序遍历：根；左子树前序遍历；右子树前序遍历
- 中序遍历：左子树中序遍历；根；右子树中序遍历
- 左右子树不管什么遍历方式，总结点树时一致的

算法：

1. 通过前序遍历确定根节点数值rootval；
2. 通过根节点数值rootval 以及中序遍历 确定 左子树中序遍历区域，右子树中序遍历区域，记录其对应的区间长度
3. 通过区间长度，计算前序遍历中左右子树的前序遍历区间；
4. 将左子树，右子树递归
5. 边界条件区间长度<0

#### 递归

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        TreeNode root = new TreeNode();
        return createTree(root,preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }
    public TreeNode createTree(TreeNode node, int[] preorder,int prefirst,int perlast,int[] inorder, int infirst, int inlast ){
        if(prefirst>perlast||inlast<infirst){
            return null;
        }
        //子树头节点
        int rootval = preorder[prefirst];
        node = new TreeNode(rootval);
        //找到子树的左子树,和右子树
        for(int i = infirst; i <= inlast; i++){
            if(inorder[i] == rootval){
                //左子树长度
                int Llength = i-infirst;
                //右子树长度
                int Rlength = inlast - i;
                node.left = createTree(node.left,preorder,prefirst+1, prefirst+ Llength,inorder,infirst,i-1);
                node.right = createTree(node.right,preorder,prefirst+Llength+1,prefirst+Llength+Rlength,inorder,i+1,inlast);
                break;
            }
        }
        return node;
    }
}
```

#### 递归 copyOfRange

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        TreeNode root = new TreeNode();
        return createTree(root,preorder,inorder);
    }
    public TreeNode createTree(TreeNode node, int[] preorder,int[]inorder){
        //子树头节点
        int rootval = preorder[0];
        node = new TreeNode(rootval);
        //找到子树的左子树,和右子树
        for(int i = 0; i < inorder.length; i++){
            if(inorder[i] == rootval){
                //左子树长度
                int Llength = i;
                //右子树长度
                int Rlength = inorder.length - i - 1;
                if(Llength>0){
                    int[] Lpreorder = Arrays.copyOfRange(preorder,1,1+Llength);
                    int[] Linorder = Arrays.copyOfRange(inorder,0,Llength);
                    node.left = createTree(node.left,Lpreorder,Linorder);    
                }else{
                    node.left = null;
                }
                if(Rlength>0){
                    int[] Rpreorder = Arrays.copyOfRange(preorder,1+Llength,preorder.length);
                    int[] Rinorder = Arrays.copyOfRange(inorder,i+1,inorder.length);
                    node.right = createTree(node.right , Rpreorder, Rinorder);
                }else{
                    node.right = null;
                }
            }
        }
        return node;
    }
}
```



### 112将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return sortedArrayToBST(nums,0,nums.length-1);

    }
    public TreeNode sortedArrayToBST(int[] nums,int first, int last){
        if(first==last){
            return new TreeNode(nums[first]);
        }
        if(first > last){//重点
            return null;
        }
        int mid = (first + last)>>1;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = sortedArrayToBST(nums,first,mid-1);
        node.right = sortedArrayToBST(nums,mid+1,last);
        return node;
    }
}
```



### 113 [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

 

**示例：**

![img](笔记图库/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

#### 层序遍历+遍历

```java
import java.util.*;
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/
class Solution {
    LinkedList<Node> listnode = new LinkedList(); 
    public Node connect(Node root) {
        if(root!=null){
            listnode.add(root);
        }
        int size = 0;
        Node node;
        while(listnode.size()!=0){
            size = listnode.size();
            for(int i = 0; i<size ; i++){
                node = listnode.poll();
                if(node.left!=null){
                    listnode.add(node.left);
                }
                if(node.right!=null){
                    listnode.add(node.right);
                }
            }
            for(int i = 0; i<listnode.size()-1; i++){
                listnode.get(i).next = listnode.get(i+1);
            } 
        }
        return root;
    }
        
}
```

复杂度分析

时间复杂度：O(N)O(N)。每个节点会被访问一次且只会被访问一次，即从队列中弹出，并建立 \text{next}next 指针。

空间复杂度：O(N)O(N)。这是一棵完美二叉树，它的最后一个层级包含 N/2N/2 个节点。广度优先遍历的复杂度取决于一个层级上的最大元素数量。这种情况下空间复杂度为 O(N)

#### 层序遍历

队列peek()

```java


class Solution {
    LinkedList<Node> listnode = new LinkedList(); 
    public Node connect(Node root) {
        if(root!=null){
            listnode.add(root);
        }
        int size = 0;
        Node node;
        while(listnode.size()!=0){
            size = listnode.size();
            for(int i = 0; i<size ; i++){
                node = listnode.poll();
                if(i<size-1) node.next = listnode.peek();
                if(node.left!=null){
                    listnode.add(node.left);
                }
                if(node.right!=null){
                    listnode.add(node.right);
                }
            }
           
        }
        return root;
    }     
}
```

```
复杂度分析

时间复杂度：O(N)O(N)。每个节点会被访问一次且只会被访问一次，即从队列中弹出，并建立 \text{next}next 指针。

空间复杂度：O(N)O(N)。这是一棵完美二叉树，它的最后一个层级包含 N/2N/2 个节点。广度优先遍历的复杂度取决于一个层级上的最大元素数量。这种情况下空间复杂度为 O(N)O(N)。
```

#### 前一层根据next遍历整层，对下一层进行连接

```java
import java.util.*;
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/
class Solution {
    public Node connect(Node root) {
        if(root == null) return root;
        Node leftmax = root;
        Node head;
        //如果下一层还有节点
        while(leftmax.left!=null){
            head = leftmax;
            while(head!=null){
                head.left.next = head.right;
                if(head.next!=null) head.right.next = head.next.left;
                head = head.next;
            }
            leftmax = leftmax.left;
        }
        return root;
    }     
}
```

### 114 买卖股票

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。



```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        int minprice = prices[0];
        for(int i = 1 ; i<prices.length; i++){
            maxprofit = Math.max(maxprofit,prices[i] - minprice);
            minprice = Math.min(minprice,prices[i]);
        }
        return maxprofit;
    }
}
```

### 115 杨辉三角 

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]



```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList();
        Integer[] array = {1};
        List l = Arrays.asList(array);
        res.add(Arrays.asList(array));
        if(numRows==1){
            return res;
        }
        res.add(Arrays.asList(1,1));
        if(numRows==2){
            return res;
        }
        for(int i = 2; i<numRows ; i++){
            List list = new ArrayList<Integer>(i);
            System.out.println(i+" "+ list.size());
            list.add(1);
            for(int j = 1; j < i; j++){
                List per = res.get(i-1);
                list.add((Integer)per.get(j-1) + (Integer)per.get(j));
            }
            list.add(1);
            res.add(list);
        }
        return res;
    }
}
```

Arrays.asList(引用类型数组)

### 116 买卖股票二

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



可以同一天 先卖出 再买入

maxprofit[1,5,6] = 6-1 也= 5-1 +  6-5

因此只要存在之前的某些天per比当前值cur小，就立即卖出，（如果后面la有比当前值更大的也没有关系，后续加上后面la -cur即可）cur置为per

否则per等于cur 和 per中的较小者

循环继续上面的步骤

**当前最大利润 = 之前所有可能的利润 + 之后从当前开始所有可能的利润**

可能的利润 =  之前的某些天per比当前值cur小，就立即卖出所获利润

```java
class Solution {
    public int maxProfit(int[] prices) {
        int perprice = prices[0];
        int maxprofit = 0;
        for(int i = 1; i<prices.length; i++){
            if(prices[i] > perprice){
                maxprofit  = maxprofit + (prices[i]-perprice);
                perprice = prices[i];
            }
            perprice = Math.min(perprice,prices[i]);  
        }
        return maxprofit;
    }
}
```

### 117 验证回文串

难度简单433

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

**示例 1:**

```
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

注意 大写字母**A~Z的ASCII码值从65~90**，小写字母**a~z的ASCII码值从97~122**

两组字符并不是连在一起的 91—96 均不是字母

**也可以用 s = s.toLowerCase();**

#### 双指针

```java
class Solution {
    public boolean isPalindrome(String s) {
        //初始化
        ArrayList<Character> charlist = new ArrayList();
         //遍历
        Character c ;
        for(int i = 0; i<s.length(); i++){
            c = letterInti(s.charAt(i));
            if(c!=null)charlist.add(c);
        }
        //判断 双指针
        int first = 0;
        int last = charlist.size()-1;
        while(last>first){
            if(!charlist.get(first).equals(charlist.get(last))) return false;
            last--;
            first++;
        }
        return true;
    }

    public Character letterInti(char c){
        if(!((c>='A'&&c<='Z')||(c>='a'&&c<='z')||(c>='0'&&c<='9'))){
            return null;
        }
        if(c>='A'&&c<='Z'){
            return (char)(c + ('a'-'A'));
        }
        return c;
    }
}
```

#### reverse

```java
class Solution {
    public boolean isPalindrome(String s) {
        StringBuffer sgood = new StringBuffer();
        int length = s.length();
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (Character.isLetterOrDigit(ch)) {
                sgood.append(Character.toLowerCase(ch));
            }
        }
        StringBuffer sgood_rev = new StringBuffer(sgood).reverse();
        return sgood.toString().equals(sgood_rev.toString());
    }
}


```

### 118[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。



**示例 1：**

![img](笔记图库/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```



通过某一结点为根节点，通过该节点的最大路径，等于左子节点的增益值+自身+右子节点的增益值

其中某节点增益值等于 该节点的值 + 左子节点增益值与右子节点增益值的较大者

- 如果增益值小于0，则取0
- 叶子节点的增益值等于本身

本质：任何最大路径的 节点 中**必然存在一个根节点**

且最大路径和 由以下三部分组成 **该根节点值 + 左子节点的增益值 + 右子节点的增益值** 

```
class Solution {
    //定义全局变量maxsum
    int maxsum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        //调用节点增益函数
        GainNode(root);
        return maxsum;
    }
    public int GainNode(TreeNode node){
        if(node == null){
            return 0;
        }
        int leftGain = Math.max(GainNode(node.left),0);
        int rightGain = Math.max(GainNode(node.right),0);
        maxsum = Math.max(leftGain+rightGain+node.val,maxsum);
        return Math.max(leftGain,rightGain)+node.val;
    }
}
```

### 119 最长连续子序列

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

示例 1：

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9

#### 排序

非O(n)注意去重

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0){
            return 0;
        }
        Arrays.sort(nums);
        int longest = 1;
        int count = 1;
        for(int i = 1; i<nums.length; i++){
            if(nums[i-1]==nums[i]) continue;
            if(nums[i-1]==nums[i]-1){
                count++;
            }else{
                longest = Math.max(count,longest);
                count = 1;
            }
        }
        longest = Math.max(count,longest);
        return longest;
    }
}
```

#### HashMap+左右扩展

**会超时**

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length==0)return 0;
        int longest = 1;
        HashMap<Integer,Object> map = new HashMap();
        for(int i = 0; i<nums.length; i++){
            map.put(nums[i],null);
        }
        for(Integer i : map.keySet()){
            int count = 1;
            int temp = i;
            while(true){
                if(map.containsKey(temp+1)){
                    temp = temp+1;
                    count++;
                }else{
                    break;
                }
            }
            
            while(true){
                if(map.containsKey(i-1)){
                    i = i-1;
                    count++;
                }else{
                    break;
                }
            }
            longest = Math.max(longest,count);
        }
        return longest;
    }
}
```



#### HashMap+左右遍历+标记

标记用new Object 代替已扩展到的元素

有标记的元素不参与后续运算

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length==0)return 0;
        int longest = 1;
        HashMap<Integer,Object> map = new HashMap();
        for(int i = 0; i<nums.length; i++){
            map.put(nums[i],null);
        }
        for(Integer i : map.keySet()){
            if(map.get(i)!=null) continue;
            int count = 1;
            int temp = i;
            map.put(temp,new Object());
            while(true){
                if(map.containsKey(temp+1)){
                    temp = temp+1;
                    count++;
                    map.put(temp,new Object());
                }else{
                    break;
                }
            }
            
            while(true){
                if(map.containsKey(i-1)){
                    i = i-1;
                    count++;
                    map.put(temp,new Object());
                }else{
                    break;
                }
            }
            longest = Math.max(longest,count);
        }
        return longest;
    }
}
```

HashMap+再边界处更新区间长度

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length==0)return 0;
        int longest = 1;
        HashMap<Integer,Integer> map = new HashMap();
        int left;
        int right;
        int curlength;
        for(int i = 0; i<nums.length; i++){
            if(map.containsKey(nums[i])){
                continue;
            }
            right = map.containsKey(nums[i]+1)? map.get(nums[i]+1):0;
            left = map.containsKey(nums[i]-1)? map.get(nums[i]-1):0;
            curlength = left+right+1;
            map.put(nums[i],curlength);
            map.put(nums[i]+right,curlength);
            map.put(nums[i]-left,curlength);
            longest = Math.max(curlength,longest);
        }
        return longest;
    }
}
```

### 120 [ 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

示例 1：

输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。



#### 递归+复制

创建一个和board相同大小的充满 X 的临时数组；

遍历board边界；如果是 O 且临时数组对应的位置不为O, 将临时数组对应的位置设为O，递归扩散四周；

”如果是 O 且临时数组对应的位置不为O“ 后半句是为了防止重复判断

最后将临时数组中的每个元素复制给board

```java
class Solution {
    public void solve(char[][] board) {
        char[][] boardtemp = new char[board.length][board[0].length];
        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                boardtemp[i][j] = 'X';
            }
        }
        for(int i = 0; i<board.length; i++){
            flagO(i,0,board,boardtemp);
        }
        for(int i = 0; i<board.length; i++){
            flagO(i,board[0].length-1,board,boardtemp);
        }
        for(int j = 0; j<board[0].length; j++){
            flagO(0,j,board,boardtemp);
        }
        for(int j =0; j<board[0].length; j++){
            flagO(board.length-1,j,board,boardtemp);
        }

        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                board[i][j] = boardtemp[i][j];
            }
        }
    }
    public void flagO(int i, int j,char[][] board, char[][] boardtemp){
        if(!(board[i][j]=='O')||boardtemp[i][j]=='O') return;
        boardtemp[i][j] = 'O';
        if(i > 0) flagO(i-1,j,board,boardtemp);
        if(i < board.length-1) flagO(i+1,j,board,boardtemp);
        if(j > 0) flagO(i,j-1,board,boardtemp);
        if(j < board[0].length-1) flagO(i,j+1,board,boardtemp);
    }
}
```

#### 标记+递归

```java
class Solution {
    public void solve(char[][] board) {
        char[][] boardtemp = new char[board.length][board[0].length];
        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                boardtemp[i][j] = 'X';
            }
        }
        for(int i = 0; i<board.length; i++){
            flagO(i,0,board);
            flagO(i,board[0].length-1,board);
        }
      
        for(int j = 0; j<board[0].length; j++){
            flagO(0,j,board);
            flagO(board.length-1,j,board);
        }

        for(int i = 0; i<board.length; i++){
            for(int j = 0; j<board[0].length; j++){
                if(board[i][j]=='A'){
                    //被包围的
                    board[i][j] = 'O';
                }else if(board[i][j]=='O'){
                    //未被包围
                    board[i][j] = 'X';
                } 
            }
        }
    }
    public void flagO(int i, int j,char[][] board){
        if(!(board[i][j]=='O')) return;
        board[i][j] = 'A';
        if(i > 0) flagO(i-1,j,board);
        if(i < board.length-1) flagO(i+1,j,board);
        if(j > 0) flagO(i,j-1,board);
        if(j < board[0].length-1) flagO(i,j+1,board);
    }
}
```

## 121-130

### 121只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

#### 排序+遍历

```java
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        int i = 0;
        while(i<nums.length-1){
            if(nums[i]!=nums[i+1]){
                return nums[i];
            }
            i = i+2;
        }
        return nums[i];
    }
}
```

#### 异或

```java
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        int res = 0;
        for(int i = 0; i<nums.length; i++){
            res = res ^ nums[i];
        }
        return res;
    }
}
```



### 122[. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

难度简单1252

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

**示例 1：**

![img](笔记图库/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

#### 双指针

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        //双指针
        ListNode faster = head;
        ListNode laster = head;
        //如果faster与laster相遇；或者下一个指针为null
        while(laster!=null && laster.next!=null && laster.next.next!=null){
            faster = faster.next;
            laster = laster.next.next;
            if(faster == laster){
                return true;
            }
        }
        return false;
    }
}
```

#### 哈希表

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
```

### 123 [加油站](https://leetcode-cn.com/problems/gas-station/)

在一条环路上有 *N* 个加油站，其中第 *i* 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 *i* 个加油站开往第 *i+1* 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

**说明:** 

- 如果题目有解，该答案即为唯一答案。
- 输入数组均为非空数组，且长度相同。
- 输入数组中的元素均为非负数。

**示例 1:**

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引
```

#### 模拟

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int gascontain;//油量
        int target ;//目标位置
        int per;//前一个位置
        for(int i = 0; i<gas.length; i++){
            gascontain = gas[i];
            per = i;
            target = i+1;
            while(gascontain!=0&&gascontain>=cost[per]){  
                if(target>gas.length-1){
                    target = 0;
                }
                if(per>gas.length-1){
                    per = 0;
                }
            
                gascontain = gascontain - cost[per] + gas[target];
                per = target;
                target++;
                if(per == i){
                    return i;
                }  
            }
        }
        return -1;
    }
}
```

#### 一次遍历

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int remain;
        int target;
        for(int i = 0; i<gas.length ; i++){
            int cur = i;
            target = cur + 1;
            remain = gas[cur];

            while(remain >= cost[cur]){
                if(target >= gas.length ){
                    target = 0;
                }
                remain = remain - cost[cur] + gas[target];
                cur = target;
                target++;
                if(cur == i){
                    return i;
                }
            }
            if(cur < i){
                return -1;
            }
            i = cur;
        }
        return -1;
    }
}
```

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
       //当前位置
       int src;
       //剩余油量
       int Remaininggas;
       //全程长度
       int length = cost.length;
       for(int i = 0 ; i<length; i++){
           //从第i位置出发
           src = i;
           Remaininggas = gas[i];
           while(Remaininggas>=cost[src]){
               //剩余油量计算
               Remaininggas = Remaininggas - cost[convertCir(src,length)] + gas[convertCir(src+1,length)];
               src = convertCir(src+1,length);
               if(src == i){
                   return src;
               }
           }
           //从i出发最多只能到达src，那么中间的位置不用重新判断了,直接从src开始判断即可
           if(src < i){
               //由于出发的位置 i已经保证了，i之前的任何位置均不可到达
               return -1;
           }
           i = src; 
       }
       return -1;
    }
    public int convertCir(int i, int length){
        if(i > length-1){
            return 0;
        }
        return i;
    }
}
```

### 124 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。


示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

#### 主栈+最小辅助栈

```java
class MinStack {
    Stack<Integer> stack; 
    Stack<Integer> Minstack; 

    public MinStack() {
        stack = new Stack();
        Minstack = new Stack();
        Minstack.push(Integer.MAX_VALUE);
    }
    
    public void push(int val) {
        stack.push(val);
        if(val<Minstack.peek()){
            Minstack.push(val);
        }else{
            Minstack.push(Minstack.peek());
        }
    }
    
    public void pop() {
        stack.pop();
        Minstack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
          
        return Minstack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### 125 分割回文串

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。

示例 1：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
示例 2：

输入：s = "a"
输出：[["a"]]

#### 回溯+双指针

```java
class Solution {
    List<List<String>> res = new LinkedList();
    public List<List<String>> partition(String s) {

        subpartition(s,0,new LinkedList());
        return res;
    }

    public boolean judge(String s, int i, int j){
        while(j>i){
            if(s.charAt(i) != s.charAt(j))
            return false;
            i++;
            j--;
        }
        return true;
    }
    public void subpartition(String s, int start,List<String> list){
        if(start >= s.length()){
            res.add(list);
        }
        //判断从start开始，出现的回文串
        for(int i = start; i<s.length(); i++ ){
            if(judge(s,start,i)){
                List<String> listtemp = new LinkedList(list);
                listtemp.add(s.substring(start,i+1));
                subpartition(s,i+1,listtemp);
            }
        }
    }
}
```

```java
//优化 
public void subpartition(String s, int start,List<String> list){
        if(start >= s.length()){
            res.add(new LinkedList(list));//优化
        }
        //判断从start开始，出现的回文串
        for(int i = start; i<s.length(); i++ ){
            if(judge(s,start,i)){   
                list.add(s.substring(start,i+1));
                subpartition(s,i+1,list);
                list.remove(list.size()-1);
            }
        }
    }
```

#### 回溯+动态规划预处理

```java
class Solution {
    List<List<String>> res = new LinkedList();
    boolean[][] dp;
    public List<List<String>> partition(String s) {
        int length = s.length();
        dp = new boolean[length][length];
        for(int i = 0; i<length; i++){
            dp[i][i] = true;
        }
        for(int L = 1; L<length; L++){
            for(int i = 0; i<length - L; i++){
                if(L == 1){
                    dp[i][i+L] = s.charAt(i) == s.charAt(i+L);     
                }else{
                    dp[i][i+L] = dp[i+1][i+L-1] && (s.charAt(i) == s.charAt(i+L));     
                }
            }
        }
        
        subpartition(s,0,new LinkedList());
        return res;
    }

    public boolean judge(String s, int i, int j){
        while(j>i){
            if(s.charAt(i) != s.charAt(j))
            return false;
            i++;
            j--;
        }
        return true;
    }
    public void subpartition(String s, int start,List<String> list){
        if(start >= s.length()){
            res.add(new LinkedList(list));//优化
        }
        //判断从start开始，出现的回文串
        for(int i = start; i<s.length(); i++ ){
            if(dp[start][i]){   
                list.add(s.substring(start,i+1));
                subpartition(s,i+1,list);
                list.remove(list.size()-1);
            }
        }
    }
}
```

### 126[复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

难度中等764

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

#### Hash

```java

class Solution {
    public Node copyRandomList(Node head) {
        //构造哈希表 键值为 原链表节点，与赋值节点
        HashMap<Node,Node> map = new HashMap();
        //遍历链表存储键值
        Node temp = head;
        while(temp!= null){
            Node node = temp;
            map.put(node , new Node(node.val));
            temp = temp.next;
        }
        temp = head;
        //连接
        while(temp!= null){
            Node node = map.get(temp);
            node.next = temp.next == null? null : map.get(temp.next);
            node.random = temp.random == null? null: map.get(temp.random);
            temp = temp.next;
        }
        return map.get(head);
    }
}
```

#### 节点插入

![image-20211120144842637](笔记图库/image-20211120144842637.png)

### 127[. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](笔记图库/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

#### 相交链表

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int Alength = 0;
        int Blength = 0;
        
        ListNode tempA = headA;
        ListNode tempB = headB;
        ListNode temp ;
        while(tempA != null){
            Alength++;
            tempA = tempA.next;
        }
        while(tempB != null){
            Blength++;
            tempB = tempB.next;
        }
        if(Alength > Blength){
            int Difference = Alength - Blength;
            while(Difference > 0){
                ListNode node = new ListNode(0);
                node.next = headB;
                headB = node;
                Difference--;
            }
        }else{
           int Difference = Blength - Alength ;
            while(Difference > 0){
                ListNode node = new ListNode(0);
                node.next = headA;
                headA = node;
                Difference--;
            }
        }
      
        while(headA != null){
            if(headA == headB){
                return headA;
            }else{
                headA = headA.next;
                headB = headB.next;
            }
        }
        return null;
    }
}
```

#### 哈希

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        HashMap<ListNode,Object> map = new HashMap();
        ListNode tempA = headA;
        ListNode tempB = headB;
        while(tempA != null){
            map.put(tempA,null);
            tempA = tempA.next;
        }
        while(tempB != null){
            if(map.containsKey(tempB)){
                return tempB;
            }
            tempB = tempB.next;
        }
        return null;
        
    }
}
```

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> map = new HashSet();
        ListNode tempA = headA;
        ListNode tempB = headB;
        while(tempA != null){
            map.add(tempA);
            tempA = tempA.next;
        }
        while(tempB != null){
            if(map.contains(tempB)){
                return tempB;
            }
            tempB = tempB.next;
        }
        return null;
        
    }
}
```

#### 双指针

AB走完全相同的路程

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode tempA = headA;
        ListNode tempB = headB;
        while(tempA!=null||tempB!=null){
            if(tempA == tempB) return tempA;
            tempA = tempA == null? headB : tempA.next;
            tempB = tempB == null? headA : tempB.next;
        }
        return null;
    }
}
```

### 128  最不常用算法

```java
class LRUCache {
    private int capacity;
    HashMap<Integer,ValueUsed> map;
    LinkedList<ValueUsed> recordUsed;
    class ValueUsed{
        public int key;
        public int value;
        public int KeyUsedTime;
        public ValueUsed(int key,int value){
            this.key = key;
            this.value = value;
            this.KeyUsedTime =1;
        }
    }

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap();
        recordUsed = new LinkedList();
    }
    
    public int get(int key) {
        if(!map.containsKey(key)){
            return -1;
        }
        map.get(key).KeyUsedTime++;
        recordUsed.sort(new Comparator<ValueUsed>(){
             @Override
            public int compare(ValueUsed o1,ValueUsed o2){
                return o1.KeyUsedTime - o2.KeyUsedTime;
            }
        });
        
    
        return map.get(key).value;
    }
    public void put(int key, int value) {
        //先判断是否存在
        if(map.containsKey(key)){
            map.get(key).KeyUsedTime++;
            map.get(key).value = value;
        }else{
            //判断是否已满
            if(recordUsed.size() >= this.capacity){
                int removeKey = recordUsed.poll().key;
                map.remove(removeKey);
            }else{
                map.put(key,new ValueUsed(key,value));
            }
            
        }
       recordUsed.sort(new Comparator<ValueUsed>(){
             @Override
            public int compare(ValueUsed o1,ValueUsed o2){
                return o1.KeyUsedTime - o2.KeyUsedTime;
            }
        });
    }
}
```

### 129[LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU) 。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**进阶**：你是否可以在 `O(1)` 时间复杂度内完成这两种操作？



两种可能的实现方法是 :

- 系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.
- 设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.

#### 哈希+链表

超时

```java
class LRUCache {
    HashMap<Integer,Integer> map;
    LinkedList<Integer> list; 
    int capacity; 

    public LRUCache(int capacity) {
        map = new HashMap();
        list = new LinkedList();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            list.remove((Integer)key);
            list.add(key);
            return map.get(key);
        }else{
            return -1;
        }
    }
    public void put(int key, int value) {
        if(map.containsKey(key)){
            list.remove((Integer)key);
            list.add(key);
            map.put(key,value);
        }else{
            if(list.size() >= capacity){
                int remKey = list.pop();
                map.remove((Integer)remKey);}
                map.put(key,value);
                list.add(key); 
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

#### 哈希+双向链表

```java
class LRUCache {
    HashMap<Integer,Node> map;
    Node head;
    Node tail;
    int capacity; 
    class Node{
        int key;
        int value;
        Node per;
        Node next;
        public Node(int key, int value){
            this.key = key;
            this.value = value;
            per = null;
            next = null;
        }
    }

    public LRUCache(int capacity) {
        map = new HashMap();
        this.capacity = capacity;
        head = new Node(-1,-1);
        tail = new Node(-1,-1);
        head.next = tail;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            update(node);
            return node.value;
        }else{
            return -1;
        }
    }
    public void put(int key, int value) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            update(node);
            node.value = value;
        }else{
            Node node = new Node(key,value);
            if(map.size() >= capacity){
                int remKey = tail.per.key;
                map.remove(remKey);
                //删尾
                tail.per.per.next = tail;
                tail.per = tail.per.per;
            }
                //插首
                node.next = head.next;
                head.next.per = node;
                node.per = head;
                head.next = node;
                map.put(key,node);      
        }
    }

    public void update(Node node){
        //先删
        node.per.next = node.next;
        node.next.per = node.per;
        //再插
        node.next = head.next;
        head.next.per = node;
        head.next = node;
        node.per = head;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

