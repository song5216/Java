# 数据结构与算法

## 1概述

### 1.1数据结构分类

逻辑结构：

- 集和结构
- 线性结构
- 树形结构
- 图形结构

物理结构：

- 顺序结构：数据元素存储在连续的内存单元，通过索引快速定位，但插入比较有难度
- 链式存储结构：数据元素存储在非连续的的内存单元，数据单元与数据单元之间通过指针连接，查询比较有难度，插入比较容易

### 1.2算法

在一定条件下，对一些数据进行计算，得到所需结果

**指标**

- 最少时间
- 占用最少空间

每递归一次，就要开辟一块内存空间，所以递归比较占空间

### 1.3时间复杂度

**加是开根号，乘是取对数**

```
i= k = 0;
while (k < n) {
    i++;
    k += i;
}
```

```
O(n^(1/2))
```

与问题的输入规模、算法采用的策列和方案 息息相关

**O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)**

1. **近似**

N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 \~ N<sup>3</sup>/6。使用 \~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。

2. **增长数量级**

N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 的增长数量级为 O(N<sup>3</sup>)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N<sup>3</sup>) 与它是否用 Java 实现，是否运行于特定计算机上无关。

3. **内循环**

执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。

4. **成本模型**

使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。

### 1.4空间复杂度

- 计算机访问内存的方式是一次一个字节。
- 一个机器地址需要8个字节：例如： Date date = new Date(),则date这个变量需要占用8个字节来表示。
- 创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。
- 存储数据需要以8个字节为单位，不足则填充
- java中数组被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。

```java
//数组反转
public static int[] reverse1(int[] arr){
int n=arr.length;//申请4个字节
int temp;//申请4个字节
for(int start=0,end=n-1;start<=end;start++,end--){
temp=arr[start];
arr[start]=arr[end];
arr[end]=temp;
}
return arr;
}
/////////////////////////////////////////
public static int[] reverse2(int[] arr){
int n=arr.length;//申请4个字节
int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节
for (int i = n-1; i >=0; i--) {
temp[n-1-i]=arr[i];
}
return temp;
```

## 2 简单排序

O(N^2)

### 2.1 Comparable 接口

#### 2.1.1接口

- 类似于抽象类，但更为抽象

- 不给出具体的实现，要统一规则

- 接口不能实例化，需要通过多态的方式进行；

- 接口的子类
  普通类：需要重写接口中所有的方法
  抽象类：

- 接口与接口之间的关系：继承

- 接口与类：实现

  (1)**接口的定义**：

  接口就是提供的统一规则和规范

  (2)接口的实现

  ```java
  //接口的定义
  public interface Smoking{
      public abstract void smoke();
  
  }
  //接口的实现
  public class Teacher implement Smoking {
      public viod smoking(){
          System.out.println("抽烟有害健康");
      }
  }
  
  //使用多态的方式进行实例化
  Smoking sm = new Teacher()//接口不能实例化，需要通过实现它的子类进行实例化
  ```

### 2.2 举例

```java
#较两个学生年龄的大小
package com.bit.compare;
//1.定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；
//2.定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试
public class student {
    private String name;
    private Comparable age;

    public student(String name, Comparable age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Comparable getAge() {
        return age;
    }

    public void setAge(Comparable age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

}


//////////////////////////////////////////////
package com.bit.compare;

public class test {
    public static void main(String[] args) {
        student W = new student("张三",7);
        student X = new student("李四",6);
        test tect = new test();
        System.out.println(tect.compare(W,X));

    }

    public String compare(student a,student b){
        if(a.getAge().compareTo(b.getAge())==1){
            return a.getName();
        }
        else return b.getName();
    }
}

```

### 2.2 冒泡排序

排序原理：
1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。**最终最后位置的元素就是最大值**。

```java
package com.bit.sort;
//1.public static void sort(Comparable[] a)：对数组内的元素进行排序
// 2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w
// 3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值
//冒出最大值排序
public class Bubblemethod {
    public static void sort(Comparable[] a) {//直接通过类名. 的形式进行调用，所以用静态方法
        for(int i=0 ;i<a.length-1;i++) {
            for(int j=0; j<a.length-1-i; j++) {
                if(Bubblemethod.greater(a[j],a[j+1])) {
                    Bubblemethod.exch(a,j,j+1);
                };
            }
        }

    }

    static boolean greater(Comparable v, Comparable w) {
        int temp=v.compareTo(w);
        if (temp==1) {
            return true;
        } else{
            return false;
        }
    }

    static void exch(Comparable[] a, int i, int j) {
        Comparable temp;
        temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }

}


///测试
    public class methodTest {
    public static void main(String[] args) {
        Comparable[] a={4,5,9,8,7,4};
        Bubblemethod.sort(a);//直接通过类名. 的形式进行调用，所以用静态方法
        System.out.println("冒泡排序");
        System.out.println(Arrays.toString(a));}}
```

**冒泡排序的时间复杂度分析** 

冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，
我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。
在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么：
元素比较的次数为：
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;
元素交换的次数为：
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;
总执行次数为：
(N^2/2-N/2)+(N^2/2-N/2)=N^2-N;
按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2).

### 2.3选择排序

**找出最小元素，放到第一个位置**

选择排序是一种更加简单直观的排序方法。
需求：
排序前：{4,6,8,7,9,2,10,1}
排序后：{1,2,4,5,7,8,9,10}
排序原理：
1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处
的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引
2.交换第一个索引处和最小值所在的索引处的值

```java
package com.bit.sort;
//选出最小值排序
public class Sectionmethod extends Bubblemethod {

    public static void sort(Comparable[] a) {
        
        for(int i=0 ;i<a.length-1;i++) {
            for(int j=i+1; j<a.length; j++) {//假设a[i]是最小元素，和后面的元素进行比较，遇到更小者交换，继续遍历，直到末尾。
                if(Sectionmethod.greater(a[i],a[j])) {
                    Sectionmethod.exch(a,i,j);
                }
            }
        }
    }
}
```

**选择排序的时间复杂度分析：**
选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据
交换次数和数据比较次数：
数据比较次数：
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;

数据交换次数：
N-1
时间复杂度：N^2/2-N/2+（N-1）=N^2/2+N/2-1;
根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);

### 2.4 插入排序

已排序和未排序

插入排序（Insertion sort）是一种简单直观且稳定的排序算法。
**排序原理：**
1.把所有的元素分为两组，已经排序的和未排序的；
2.找到未排序的组中的第一个元素，向已经排序的组中进行插入；
3.**倒叙遍历已经排序的元素**，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；

```java
public class Insertionmethod extends Bubblemethod{
    public static void sort(Comparable[] a) {
            for(int i=0 ;i<a.length-1;i++) {
                for(int j=i+1;j>0; j--) {
                    if(Sectionmethod.greater(a[j-1],a[j])) {//这一步类似于冒泡
                        Sectionmethod.exch(a,j-1,j);
                    } else{
                        break;//注意点
                    };
                }
            }
    }
}
```

**插入排序的时间复杂度分析**
插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复
杂度，主要分析一下内层循环体的执行次数即可。
最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么：
比较的次数为：
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;
交换的次数为：
(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;
总执行次数为：
(N^2/2-N/2)+(N^2/2-N/2)=N^2-N;
按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(N^2).

## 3 高级排序

### 3.1希尔排序

插入排序的改良版

**排序原理：**
1.选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；
2.对分好组的每一组数据完成插入排序；
3.减小增长量，最小减为1，重复第二步操作。
增

```java
package com.bit.sort;
public class Shellmethod {
    public static void sort(Comparable[] a) {
        int N=a.length;
        int h=1;
        while (h<N/2) {
            h=2*h+1;
        }
        while(h>=1) {
            for (int k=0; k<h; k++){ //分组，K定义分组的中i的初始索引，也可以称为第k组
                for(int i=k ;i<a.length-h ;i=i+h) {//第k个分组进行插入排序; a.length-h这个临界值使得i刚好可以达到分组的次大索引。
//每个位置必有一个最后的元素，一共有h个最后元素。
                    for(int j=i+h;j>k; j=j-h) {
                        if (Sectionmethod.greater(a[j - h], a[j])) {
                            Sectionmethod.exch(a, j - h, j);
                        } else {
                            break;//注意点
                        }
                    }
                }
            }
                h=h/2;
        }

    }
}

```

```java
//插入排序和希尔排序对比
public class ShellmethodComparetoInsertionmethod {
    public static void main(String[] args) {
        Integer a[]=new Integer[100000];

        for (int i =0; i<100000; i++){
            a[i]=100000-i;
        }

//
//        //获取执行时间
//        long start = System.currentTimeMillis();
//        //执行算发
//        Shellmethod.sort(a);
//        System.out.println("希尔排序");
//        //获取执行算法之后的时间
//        long end = System.currentTimeMillis();
//        System.out.println(Arrays.toString(a));
//
//        //计算算法执行时间
//        System.out.println(end-start);
//
        //获取执行时间
        long start_ = System.currentTimeMillis();
        //执行算发
        Insertionmethod.sort(a);
        System.out.println("插入排序");
        //获取执行算法之后的时间
        long end_ = System.currentTimeMillis();

        //计算算法执行时间
        System.out.println(end_-start_);

    }
}
```

### 3.2 归并排序

归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序
表，称为二路归并。

**排序原理：**
1.尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。
2.将相邻的两个子组进行合并成一个有序的大组；
3.不断的重复步骤2，直到最终只有一个组为止。

```java
package com.bit.sort;
//1.public static void sort(Comparable[] a)：对数组内的元素进行排序
//2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进
//行排序
//3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到所以mid为一个子
//组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从
//索引lo到索引hi）
//4.private static boolean less(Comparable v,Comparable w):判断v是否小于w
//5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值

//多次递归拆分数组至成对（两个），对两个进行排序，排序以后送入原数组中，上层递归使用之前排序好的数组继续排序；
public class Mergemethod {
    private static Comparable[] arrest;
   
    public static void sort(Comparable[] a) {//对原数组进行排序
        arrest= new Comparable[a.length];//构造辅助数组
        int hi = a.length-1;   //a.length-1  '-1'
        int lo = 0;
        sort( a, lo, hi);
    }

    private static void sort(Comparable[] a,int lo,int hi ) {//分而治之
        if(lo>=hi) {
            return;
        }
        int mid = lo + (hi-lo)/2;
        sort(a,lo,mid);//分
        sort(a,mid+1,hi);
        merge(a,lo,hi,mid);//治
    }

    private static void merge(Comparable[] a,int lo,int hi, int mid) {

        int i = lo;
        int p1=lo;
        int p2=mid+1;   //mid+1

        while(p1<=mid && p2<=hi) { //p1<=mid
            if (a[p1].compareTo(a[p2]) < 0) {
                arrest[i++] = a[p1++];
            } else {
                arrest[i++] = a[p2++];
            }
        }
            while(p1<=mid) {
                arrest[i++]=a[p1++];
            }
            while(p2<=hi){
                arrest[i++]=a[p2++];
            }
        for(int j=lo;j<=hi ;j++) { //j<=hi 
            a[j]=arrest[j];
        }
    }
}
```

```java
package com.bit.sort;
//1.public static void sort(Comparable[] a)：对数组内的元素进行排序
//2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进
//行排序
//3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到所以mid为一个子
//组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从
//索引lo到索引hi）
//4.private static boolean less(Comparable v,Comparable w):判断v是否小于w
//5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值

//多次递归拆分数组至成对（两个），对两个进行排序，排序以后送入原数组中，上层递归使用之前排序好的数组继续排序；
public class Mergemethod{

    //定义一个辅助数组
    public static Comparable[] arrest;

   // 定义一个sort方法对全局数组进行排序

    public static Comparable[] sort(Comparable[] a){
        //初始化辅助数组
        arrest = new Comparable[a.length];
        int lo = 0;
        int hi = a.length-1;
        int mid = (lo+hi)/2;
        sort(a, lo, mid, hi);
        return a;
    }
   // 定义一个重载的sort方法对分组数组进行排序和合并
    public static void sort(Comparable[] a, int lo, int mid, int hi){

        //递归边界
        if(lo>=hi){
            return;
        }
        //继续拆分
        sort(a,lo,(lo+mid)/2,mid);
        sort(a,mid+1,(mid+1+hi)/2, hi);
        //合并
        merge(a, lo, mid, hi);
    }
   // 定义一个merge方法在sort中对已有数组进行合并并排序
    public static void merge(Comparable[] a, int lo, int mid, int hi){

        //定义两个指针
        int p1 = lo;
        int p2 = mid+1;
        //定义一个arrest的首指针
        int p = lo;
        //两个指针对应索引元素比较，较大者放入辅助数组中，指针后移
        while(p1<=mid&&p2<=hi){
            if(a[p1].compareTo(a[p2])<0){
                arrest[p++]=a[p1++];
            }else{
                arrest[p++]=a[p2++];
            }
        }
        //两个指针中有一个指针移到末尾
        while(p1<=mid){
            arrest[p++]=a[p1++];
        }
        while(p2<=hi){
            arrest[p++]=a[p2++];
        }
        //将辅助数组copy到原数组
        for (int i= lo; i<=hi; i++){
            a[i]=arrest[i];
        }
    }

}

```

**时间复杂度分析：**

假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面3×2^3中的3这个层数，最终得出的归并排序的时间复杂度为：log2(n)×2^(log2(n))=log2(n)×n,根据大O推导法则，忽略底数，最终归并排序的时间复杂度为**O(nlogn);**
归并排序的缺点：
需要申请额外的数组空间(**辅助数组**)，导致空间复杂度提升，是典型的以空间换时间的操作。

### 3.3快速排序

**排序原理：**
1.首先设定**数组首值**为一个分界值，通过该**分界值将数组分成左右两部分**；
2.**将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边**。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值；
3.然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
4.重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。



```java
package com.bit.sort;

public class Quickmethod_2 {
    public static void sort (Comparable[] a){
        int lo = 0;
        int hi = a.length-1;
        sort(a,lo,hi);
    }
    private static void sort(Comparable [] a,int lo,int hi){
        //初始化两个指针，第二个索引以及最后一个索引
        int left = lo+1;
        int right = hi;
        int mid = 0;

        //递归边界
        if(lo>=hi){
            return;
        }
        //指针移动寻找大于首元素的值和小于首元素的值（循环操作至两个指针相遇）
        while(true) {
            
            //二号指针找到小于首元素的元素时停止
            while(a[right].compareTo(a[lo])>0){  //二号指针需要先移动
                right--;
                if (right==lo){//这一步和lo比较很关键，不是lo+1
                     break;//已经扫描到最左边了，无需继续扫描
                    }
            }
            //一号指针找到大于首元素的元素时停止
            while(a[left].compareTo(a[lo])<0){
                left++;
                if (left==hi){
                    break;//已经扫描到了最右边了，无需继续扫描
                    }
            }

            //一号二号指针元素交换
            if(right>left){
                exch(a,left,right);
            }else{
                //扫描完所有元素
                break;
            }
        }
        
        //两个指针相遇初索引设定成right，或者right指针直接走到尽头未相遇；并将首元素和此处的元素进行交换
        exch(a,lo,right);//right分界点赋值
       
        //递归
        sort(a,lo,right-1); //-1
        sort(a,right+1,hi); //+1
    }


    private static void exch(Comparable []a,int i,int j){
        Comparable temp;
            temp=a[i];
            a[i]=a[j];
            a[j]=temp;

    }
}

```

```java

//最佳
class Solution {
    public void sortColors(int[] nums) {
        sort(nums,0,nums.length-1);
    }
    public void sort(int[] nums, int front, int back){
        if(front>=back){
            return;
        }
        //定义双指针
        int first = front;//关键
        int last = back;
        int division = nums[front];
        //根据首位元素 分两端段
        while(first<last){
            //先从后向前找小，停
            while(first<last&&nums[last]>=division){
                last--;
            }
            
            //再从前向后找大，停
            while(first<last&&nums[first]<=division){
                first++;
            }
            
            //大小交换
            exch(nums,first,last);

            //相遇时 ,因为是 找小者 先移动最终相遇时 如果有小数一定相遇在此处；没有的话则相遇在h
        }
    
        exch(nums,front,first);

        sort(nums,front,first-1);
        sort(nums,last+1,back);
    }
    public void exch(int[] nums,int i ,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**快速排序时间复杂度分析：**
快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个
快速排序的时间复杂度和切分的次数相关。

**平均情况：**每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证
明，快速排序的时间复杂度为O(nlogn),由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对
平均情况的时间复杂度做证明了。

### 3.3.1快速排序和归并排序的区别：

- **快速排序是另外一种分治的排序算法，**它将一个数组分成两个子数组，将两部分独立的排序。
- **归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序**，
- 而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了，**没有并的过程**。
- 在**归并排序中，一个数组被等分**为两半，归并调用发生在处理整个数组之前，
- 在**快速排序中，切分数组的位置取决于数组的内容**，递归调用发生在处理整个数组之后。

## 4 线性表

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

### 4.1顺序表

#### **4.1.1 顺序表的增删改查**

顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是**指用一组地址连续的存储单元**，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即**通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。**

```4.2ava
package com.bit.list;

import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Consumer;

public class Sequencelist<T> implements  Iterable{
    private T[] eles;//顺序表
    public Sequencelist() {
        T[] eles = (T[]) new Object[0];//初始化空数组
        this.eles=eles;


    }

    public void clear() {
        T[] eles = (T[]) new Object[0];//数组格式化
    }

    public int length() {
        return this.eles.length;
    }
    public boolean isEmpty() {
        return eles.length==0;
    }

    public T get(int i) {
        return this.eles[i];
    }
    //插入算法，为保证插入之后，数组长度+1，需要引入辅助数组
    public void insert (int i ,T t) {
        T[] temp = (T[])new Object[this.eles.length+1];//先创建一个新数组 长度大于1
        for (int j =this.eles.length-1; j >=i; j--) {//将i之后的元素向后移动一位复制到temp中；
            temp[j+1]=this.eles[j];
        }
        temp[i]=t;
        for (int j=0; j <i; j++){//将i之前的数组复制到temp中
            temp[j]=this.eles[j];
        }
       this.eles=temp;//tempcopyto eles
    }
    public void insert(T t) {
        T[] temp = (T[])new Object[this.eles.length+1];//类似
        temp[this.eles.length]=t;
        for (int j=0; j <this.eles.length; j++){
            temp[j]=this.eles[j];
        }
        this.eles=temp;

    }
    public T remove(int i) {
        if (i<0 || i>eles.length-1){
            throw new RuntimeException("当前要删除的元素不存在");
        }
        T[] temp = (T[])new Object[this.eles.length-1];
        T Re= this.eles[i];
        for (int j =i; j <this.eles.length-1; j++) {
            temp[j]=this.eles[j+1];
        }

        for (int j=0; j <i; j++){
            temp[j]=this.eles[j];
        }
        this.eles=temp;
        return Re;
    }//删除并返回线性表中第i个数据元素。
    
    public int indexOf(T t) {
        for (int i=0; i<this.eles.length; i++) {
            if(this.eles[i]==t){
                return i;
            }
        }
        return -1;
    }


    @Override
    public Iterator iterator() {
        return new SIterator();
    }
    private class SIterator implements Iterator{
        private int cur;
        public SIterator(){
            this.cur=0;
        }
//        @Override
//        public void forEachRemaining(Consumer action) {
//
//        }

        @Override
        public boolean hasNext() {
            return this.cur< eles.length;
        }
        @Override
        public Object next() {
            return eles[cur++];
        }
    }
}



//测试
package com.bit.list;

import java.sql.SQLOutput;

public class SequencelistTest {
    public static void main(String[] args) {
        Sequencelist<Integer> sl = new Sequencelist<>();
        //测试插入
        sl.insert(1);
        sl.insert(2);
        sl.insert(3);
        sl.insert(4);
        sl.insert(2,4);
//测试获取
        int getResult = sl.get(2);
        System.out.println("获取索引1处的结果为："+getResult);
//测试删除
        Object removeReult =sl.remove(1);//null赋值给int 会报空指针异常；
        System.out.println("删除的元素是："+removeReult);
//测试清空
       // sl.clear();
       // System.out.println("清空后的线性表中的元素个数为:"+sl.length());
        for (Object i:sl) {
            System.out.println(i);
        }
    }
}

```

#### 4.1.2 顺序表的时间复杂度

- get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);
- insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时间复杂为O(n);
- remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复杂度为O(n);
- 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的**时间复杂度不是线性的**，**在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显**

#### 4.1.3java中ArrayList实现

       ArrayList<Integer> a = new ArrayList(int initialCapacity);

java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。

- [x] 1.是否用数组实现；
- [x] 2.有没有扩容操作；
- [x] 3.有没有提供遍历方式；

### 4.2 链表

之前我们已经使用顺序存储结构实现了**线性表**，我们会发现虽然顺序表的查询很快，时间复杂度为O(1),但是**增删的效率是比较低**的，因为**每一次增删操作都伴随着大量的数据元素移动**。这个问题有没有解决方案呢？

有，我们可以使用另外一种存储结构实现线性表，链式存储结构。
**链表是一种物理存储单元上非连续、非顺序的存储结构**，**其物理结构不能只管的表示数据元素的逻辑顺序**，数据元素的逻辑顺序是通过链表中的**指针链接次序实现的**。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。

#### 4.2.1单项链表的增删改查

单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。**链表的头结点的数据域不存储数据**，指针域指向第一个真正存储数据的结点。

**头结点的作用：找到这个单向链表**

```java
package com.bit.list;

import java.util.Iterator;

public class Linklist<T> implements Iterable<T> {
//1.public void clear()：空置线性表
//2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false
//3.public int length():获取线性表中元素的个数
//4.public T get(int i):读取并返回线性表中的第i个元素的值
//5.public void insert(T t)：往线性表中添加一个元素；
//6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。
//7.public T remove(int i):删除并返回线性表中第i个数据元素。
//8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。
//private class Node:结点类
//1.private Node head:记录首结点
//2.private int N:记录链表的长度
    private Node head;
    private int N;

    public Linklist() {//构造方法
        this.head =new Node(null);//结点初始化
        this.N = 0;//定义数据长度为0
    }

    public Node getHead() {
        return head;
    }

    class Node{//定义一个内部类Node
        private T item;//结点的数值
        private Node next;//结点的next

        public Node(T item) {
            this.item = item;
            this.next=null;
        }

        public T getItem() {
            return item;
        }

        public Node next(){
            return this.next;
        }
    }

    public void insert(T t) {
        Node node = new Node(t);//定义一个新结点
        Node temp = head;//引用传递
        while(temp.next()!=null){
            temp=temp.next;
        }
        temp.next=node;
        N++;
//
    }//往线性表中添加一个元素；

    public int length(){
        return this.N;
    }
    public T get(int i) { //获取第i个索引的数值
        if (i>N||i<0)
        {
            System.out.println("输入定位异常");
            throw new RuntimeException("位置不合法！");
        }
        Node temp= head;//此时head和temp的地址相同
        //对象类型参数：对象作为参数传递时，将对象在内存中的地址拷贝了一份传递给了参数对形参的处理会影响实参。
        for(int j=1; j<=i; j++) {
            temp=temp.next;
        }
        return temp.getItem();
    } //读取并返回线性表中的第i个元素的值

    public void insert(int i,T t) {
        if (i>N||i<0)
        {
            System.out.println("输入定位异常");
            throw new RuntimeException("位置不合法！");
        }
        Node node =new Node(t);
        Node temp= head;
        for(int j=1; j<i; j++) {
            temp=temp.next;
        }
        node.next=temp.next;
        temp.next=node;
        N++;
    }//在线性表的第i个元素之前插入一个值为t的数据元素。
    public T remove(int i) {
        if (i>N||i<0)
        {
            System.out.println("输入定位异常");
            throw new RuntimeException("位置不合法！");
        }

        Node temp= head;
        for(int j=1; j<i; j++) {
            temp=temp.next;
        }
        T K=temp.next.getItem();//获取被删除结点的数值

        temp.next=temp.next.next;//第i个结点的前一个结点连接i的后一个结点
        N--;
        return K;

    }//删除并返回
    // 线性表中第i个数据元素。

       public int indexOf(T t) {
        Node temp = head;
        for(int i=0;i<N;i++){
            if (t== head.getItem()){
                return i;
            }
        }
        return -1;
       }//返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。


    @Override
    public Iterator iterator() {
        return new LIterator();
    }
    private class LIterator implements Iterator<T>{
        private Node n;
        public LIterator() {
            this.n = head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }
        @Override
        public T next() {
            n = n.next;
            return n.item;
        }
    }
}
```

```java
//测试
package com.bit.list;

//注意：此链表将头结点的索引设为了0；
public class LinklistTest {
    public static void main(String[] args) {

        Linklist T1= new Linklist();
        T1.insert(2);
        T1.insert(3);
        T1.insert(4);
        Linklist.Node temp = T1.getHead();
        for(int i =0;i<T1.length();i++){
            System.out.println(temp.next().getItem());
            temp=temp.next();
        }
        System.out.println(".................................");
        T1.insert(2,4);
        System.out.println("删除第3个元素"+T1.remove(3));
        System.out.println("获取第1个元素"+T1.get(1));

        System.out.println("链表的长度为"+T1.length());
        for (Object i:T1
             ) {
            System.out.println(i);
        }


    }
}

```

#### 4.2.2 双向链表的增删改查

双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。**链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null**，指向后继结点的指针域指向第一个真正存储数据的结点。

```java
package com.bit.list;

import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Consumer;

//TowWayLinkList()：创建TowWayLinkList对象
//        成员方法
//        1.public void clear()：空置线性表
//        2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false
//        3.public int length():获取线性表中元素的个数
//        4.public T get(int i):读取并返回线性表中的第i个元素的值
//        5.public void insert(T t)：往线性表中添加一个元素；
//        6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。
//        7.public T remove(int i):删除并返回线性表中第i个数据元素。
//        8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则
//        返回-1。
//        9.public T getFirst():获取第一个元素
//        10.public T getLast():获取最后一个元素
//        成员内部
//        类
//private class Node:结点类
//        成员变量
//        1.private Node first:记录首结点
//        2.private Node last:记录尾结点
//        2.private int N:记录链表的长度
public class TwowayLinklist<T> implements Iterable{
    private Node first;
    private Node last;
    private int N;



    private class Node{
        private T item;
        private Node per;
        private Node next;

        public Node(T item, Node per, Node next) {
            this.item = item;
            this.per = per;
            this.next = next;
        }
    }

    public TwowayLinklist() {
        this.first = new Node(null,null,null);
        this.last = new Node(null,first,null);//定义首尾结点，尾部结点也不存储数据，主要用来方便了结点的插入。
        this.first.next=last;
        N =0;
    }

    public void  clear(){
        this.first.per=null;
        this.first.next=null;
        this.first.item=null;
        this.last.next=null;
        this.last.per=null;
        N=0;
    }
    public boolean isEmpty(){
        return N==0;
    }

    public T get(int i){//获得第i个元素
        if (i>N||i<0)
        {
            System.out.println("输入定位异常");
            throw new RuntimeException("位置不合法！");
        }
        TwowayLinklist.Node temp= first;//拷贝一份first的地址赋给temp
        for(int j=0; j<i; j++) {//查找第i个元素，注意首结点的下一个结点是第一个元素；
            temp=temp.next;
        }
        return (T) temp.item;
     //读取并返回线性表中的第i个元素的值
    }

    public void insert(T t) {
        Node node = new Node(t,null,null);
        node.per = last.per;
        last.per.next = node;
        node.next=last;
        last.per = node;
        N++;
    }

    public void insert(int i,T t) {
        if(i>N||i<=0){
            throw new RuntimeException("这个位置不合法");
        }
        Node node =new Node(t,null,null);
        Node temp =first;
        for(int j=0;j<i;j++){//寻找第i个元素，首结点的next为第一个元素；
            temp=temp.next;
        }
        temp.per.next = node;
        node.per = temp.per;
        temp.per = node;
        node.next = temp;
        N++;
    }

    public T remove( int i){
        if (i>N||i<1)
        {
            System.out.println("输入定位异常");
            throw new RuntimeException("位置不合法！");
        }

        Node temp= first;
        for(int j=0; j<i; j++) {
            temp=temp.next;
        }
        T K=temp.item;
        temp.next.per=temp.per;//i的前一个结点连接i的后一个结点
        temp.per.next=temp.next;
        N--;
        return K;

    }

    public int length(){
        return N;
    }
    public T getFirst(){
        return first.item;
    }

    public T getLast(){
        return last.item;
    }

    @Override
    public Iterator iterator() {
        return new LIterator();
    }
    private class LIterator implements Iterator<T>{
        private Node n;
        public LIterator() {
            this.n = first;
        }
        @Override
        public boolean hasNext() {
            return n.next.item!=null;
        }
        @Override
        public T next() {
            n = n.next;
            return n.item;
        }
    }

}

```

```java
package com.bit.list;

public class TwowayLinklistTest {
    public static void main(String[] args) throws Exception {
        TwowayLinklist<String> list = new TwowayLinklist();
        list.insert(0,"张三");
        list.insert(1,"张三");
        list.insert(2,"李四");
        list.insert(3,"王五");
        list.insert(4,"赵六");
//测试length方法
        for (Object s : list) {
            System.out.println(s);
        }
        System.out.println(list.length());
        System.out.println("-------------------");
//测试get方法
        System.out.println(list.get(2));
        System.out.println("------------------------");
//测试remove方法
        String remove = list.remove(1);
        System.out.println(remove);
        System.out.println(list.length());
        System.out.println("----------------");;
        for (Object s : list) {
            System.out.println(s);
        }}
}

```

#### 4.2.3 java中LinkedList实现

java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法
1.底层是否用双向链表实现；
2.结点类是否有三个域：**两个指针，一个数据**

#### 4.2.4 链表的复杂度分析

- get(int i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O(n)
- insert(int i,T t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n);
- remove(int i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多
- 时间复杂度为O(n)相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，**因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,同时它并没有涉及的元素的交换。**
  **相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。**

#### 4.2.5 链表的反转

​	单链表的反转，是面试中的一个高频题目。

```java
   public void reverse(){
        reverse(head.next);//因为后续涉及到head.next更改，
        // 这里不能写reverse(head)，否则第125行和第133会冲突，导致循环指针
    }
    public Node reverse(Node node){
        if(node.next==null){//边界条件要设在前面
            head.next = node;//找到尾结点，将首结点指向它
            return node;
        }
        Node per = reverse(node.next);//返回值为前序结点
        per.next = node;//指针反转
        node.next = null;//当前结点的下一个结点设为null
        return node;
    }

     public void reverse1(Node curr){  //更容易理解
            if(curr.next==null){//边界条件要设在前面
                head.next = curr;//找到尾结点，将首结点指向它
                return;
            }
            reverse1(curr.next);
            Node per = curr.next;//指针反转
            per.next = curr;
            curr.next = null;//当前结点的下一个结点设为null
            return;
        }


```

#### 4.2.6 快慢指针

​	快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍.

##### 4.2.6.1中间值问题

我们先来看下面一段代码，然后完成需求。

```java
    public T getmid(){//快慢指针问题查找中间值
        Node slow = head.next;
        Node fast = head.next;
        while(fast.next!=null&&fast!=null){  //不能应fast.next.next 因为当fast是为结点时它下一个结点等于null，null会继续next，这是会空指针异常；
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow.item;
    }
```

##### 4.2.3.2 单向链表是否有环问题

```java
 public boolean iscircle(){//判断链表是否有环
        Node slow = head.next;
        Node fast = head.next;
        while(fast.next!=null&&fast!=null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast==slow){
                return true;
            }
        }
        return false;

    }
```

##### 4.2.4.3 环入口问题

快慢两个指针相遇时，此时使用临时指针指向首结点，临时指针和慢指针同时移动，相遇处就是环入口；



#### **4.2.7 循环链表与约瑟夫问题**

```java
package com.bit.list;

public class CircleList<T> extends Linklist {

    public Node head;
    private int N;
    public CircleList() {
        head =new Node(null);
        head.next=head;
        N=1;
    }

    @Override
    public void insert(Object t) {
        Node node = new Node(t);//定义一个新结点
        Node temp = head;//引用传递
        if(head.next==head&&head.getItem()==null){
            head.setItem(t);
        }
        else{
            while(temp.next!=head){
                temp=temp.next;
            }
            temp.next=node;
            node.next = head;
        }
        N++;
//
    }//往线性表中添加一个元素；

}


//约瑟夫问题
package com.bit.list;
public class CircleListTest {
    public static void main(String[] args) {//约瑟夫问题
        CircleList Josfu = new CircleList();
        for(int i =1; i<=41; i++){
            Josfu.insert(i);
        }
        Linklist.Node temp = Josfu.head;
        Linklist.Node temp_;
        int count = 1;
        while(temp.next!=temp){
            temp_=temp; //临时结点,用于remove
            temp = temp.next;
            count++;
            if(count==3){
                count=0;
                System.out.println(temp.getItem());
                temp_.next=temp.next;
            }
        }
        System.out.println(temp.getItem());
    }
}

```

### 4.3 栈

用链表实现栈

```java
package com.bit.list;

import java.util.Iterator;

public class Stacklist<T> implements Iterable{
    private Node head;
    private int N;

    public class Node{
        private Node next;
        private T item;

        public Node(T t) {
            this.item = t;
        }

    }

    public Stacklist() {
        head = new Node(null);
        N = 0;
    }

    public boolean isEmpty() {
        if(N==0&&head.next==null){
            return true;
        }
        return false;
    }

    public int size() {
        return N;
    }

    public T pop(){
        if (head.next==null){
            return null;
        }
        T temp = head.next.item;
        head.next=head.next.next;
        N--;
        return temp;

    }

    public void push(T t) {
        Node node = new Node(t);
        if(head.next==null){
            head.next=node;
        } else{
            node.next=head.next;
            head.next=node;
        }
        N++;
    }

    @Override
    public Iterator iterator() {
        return new SIterator();
    }

    public class SIterator implements Iterator {

        private Node n=head;
        public SIterator() {
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public T next() {

            n=n.next;
            return n.item;
        }
    }
    //    Stack)：创建Stack对象
//成员方法
//1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false
//2.public int size():获取栈中元素的个数
//3.public T pop():弹出栈顶元素
//4.public void push(T t)：向栈中压入元素t
//成员变量
//1.private Node head:记录首结点
//2.private int N:当前栈的元素个数
}
```

##### 4.3.1 括号匹配问题

字符串中的小括号是否成对出现

```java
package com.bit.list;

public class StacklistBracketMatch {
    public static void main(String[] args) {
        String str1 = "((1+2)*3+4)";
        String str2 = "((1+2)*3+4";
        System.out.println(isMatch(str1));
        System.out.println(isMatch(str2));
    }

    private static boolean isMatch(String str) {
        Stacklist stack = new Stacklist();
        //遍历字符串
        for (int i = 0; i <str.length() ; i++) {
            if(str.charAt(i)=='('){
                stack.push('(');
            }
            if(str.charAt(i)==')'){
                if(stack.pop()==null){
                    return false;
                }
            }
        }
        if(stack.pop()==null){
            return true;
        }
        return false;
        //找到（压入栈
        //找到）将（弹出栈
        //直到遍历结束
        //查看堆中是否有元素
        //如果有则返回false
        //如果没有则返回true

    }
}
```

##### 4.3.2 逆波兰表达式

逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式？要搞清楚逆波兰表达式，我们得从中缀表达式说起。
**中缀表达式：**
中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。
中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。
**逆波兰表达式(后缀表达式)：**
逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。



**分析**：

遍历字符串遇到数字字符，将数字字符转化成数字并压入栈中

遇到运算字符，使用switch(){case :}语句 将栈中前两个栈帧弹出并作计算，计算结果压入栈中

遍历结束，弹出最后结果

若弹出结果后，pop！=null则表达式错误

```java
package com.bit.list;

public class StacklistNiboL {
    public static void main(String[] args) {
//中缀表达式3*（17-15）+18/6的逆波兰表达式如下
        String[] notation = {"3", "17", "15", "-", "*", "18", "6", "/", "+"};
        calculates(notation);
    }

    public static void calculates(String[] notations){
        Stacklist<Integer>s = new Stacklist();
        for (String i:notations) {
            Integer O1;
            Integer O2;
            Integer result;
            switch (i){
                case "+":
                    O1=s.pop();
                    O2=s.pop();
                    result=O2+O1;
                    s.push(result);
                    break;
                case "-":
                    O1=s.pop();
                    O2=s.pop();
                    result=O2-O1;
                    s.push(result);
                    break;
                case "*":
                    O1=s.pop();
                    O2=s.pop();
                    result=O2*O1;
                    s.push(result);
                    break;
                case "/":
                    O1=s.pop();
                    O2=s.pop();
                    result=O2/O1;
                    s.push(result);
                    break;

                default:
                    s.push(Integer.parseInt(i));
                    break;

            }
        }
        Integer result=s.pop();
        if(s.size()==0){
            System.out.println("逆波兰表达式的结果为"+result);
        }else{
            throw new RuntimeException("中序表达式的结果输入有误");
        }


    }
}
```

### 4.4 队列

先入先出

#### 4.4.1使用链表实现队列

**分析：**

使用链表的首结点作为队列的首部，这样便于队列中元素的插入与删除

```java
package com.bit.list;

public class SequenceList<T> extends Linklist{

    public T dequeue(){
        if(super.head.next==null){//如果队列中没有元素则返回null
            return null;
        }
        Node temp = super.head.next;//提取队列中的第一个元素
        Object t = temp.getItem();
        super.head.next=temp.next;//删除队列中的第一元素
        return (T) t;
    }//从队列中拿出一个元素

    public void enqueue(T t){
        Node insert = new Node(t);
        Node temp = super.head;
        while(temp.next!=null){
            temp = temp.next;
        }
        temp.next = insert;

    }//往队列中插入一个元素
}

```

#### 4.4.2 使用数组实现队列

**分析：**

```java
package com.bit.list;

import java.util.Iterator;

//SequenceList(int capacity)：创建容量为capacity的SequenceList对象成员方法
//1.public void clear()：空置线性表
//2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false
//3.public int length():获取线性表中元素的个数
//4.public T get(int i):读取并返回线性表中的第i个元素的值
//5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。
//6.public void insert(T t):向线性表中添加一个元素t
//7.public T remove(int i):删除并返回线性表中第i个数据元素。
//8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。
// 成员变量
//1.private T[] eles：存储元素的数组
//2.private int N:当前线性表的长度
public class SequenceArray<T> implements  Iterable{
    private T[] eles;

    public SequenceArray() {
        T[] eles = (T[]) new Object[0];
        this.eles=eles;
    }


    public void clear() {
        T[] eles = (T[]) new Object[0];
    }

    public int length() {
        if(this.eles==null)
            return 0;
        return this.eles.length;
    }
    public boolean isEmpty() {
        return eles.length==0;
    }

    public T get(int i) {
        return this.eles[i];
    }
    public void insert (int i ,T t) {
        T[] temp = (T[])new Object[this.eles.length+1];
        for (int j =this.eles.length-1; j >=i; j--) {
            temp[j+1]=this.eles[j];
        }
        temp[i]=t;
        for (int j=0; j <i; j++){
            temp[j]=this.eles[j];
        }
       this.eles=temp;
    }
    public void insert(T t) {
        T[] temp = (T[])new Object[this.eles.length+1];
        temp[this.eles.length]=t;
        for (int j=0; j <this.eles.length; j++){
            temp[j]=this.eles[j];
        }
        this.eles=temp;

    }
    public T remove(int i) {
        if (i<0 || i>eles.length-1){
            throw new RuntimeException("当前要删除的元素不存在");
        }
        T[] temp = (T[])new Object[this.eles.length-1];
        T Re= this.eles[i];
        for (int j =i; j <this.eles.length-1; j++) {
            temp[j]=this.eles[j+1];
        }

        for (int j=0; j <i; j++){
            temp[j]=this.eles[j];
        }
        this.eles=temp;
        return Re;
    }//删除并返回线性表中第i个数据元素。
    public int indexOf(T t) {
        for (int i=0; i<this.eles.length; i++) {
            if(this.eles[i]==t){
                return i;
            }
        }
        return -1;
    }


    @Override
    public Iterator iterator() {
        return new SIterator();
    }
    private class SIterator implements Iterator{
        private int cur;
        public SIterator(){
            this.cur=0;
        }
//        @Override
        @Override
        public boolean hasNext() {
            return this.cur< eles.length;
        }
        @Override
        public Object next() {
            return eles[cur++];
        }
    }
}

```

### 4.5 符号表

#### 4.5.1 **符号表的实现**

链表（每一个结点以键值对的形式存储）

```java
package com.bit.list;

import com.sun.source.tree.NewArrayTree;

import java.util.Iterator;
import java.util.Spliterator;

//SymbolTable()：创建SymbolTable对象
//        成员方法
// 1.public Value get(Key key)：根据键key，找对应的值
// 2.public void put(Key key,Value val):向符号表中插入一个键值对
// 3.public void delete(Key key):删除键为key的键值对
// 4.public int size()：获取符号表的大小
//  成员变量
// 1.private Node head:记录首结点
// 2.private int N:记录符号表中键值对的个数
public class Symboltable<T> implements  Iterable{
    private Node head;
    private int N;

    public class Node{

        private Integer key;
        private T value;
        public Node Next;

        public Node(Integer key, T value, Node next) {
            this.key = key;
            this.value = value;
            this.Next=next;

        }
    }

    public Symboltable() {
        this.head = new Node(null,null,null);
        this.N=0;
    }

    public  T get(Integer key){
        Node temp=head;
        while(temp.key!=key&&temp.Next!=null){
            temp=temp.Next;
        }
        if(temp.key==key){
            return temp.value;
        }
        else{
            throw new RuntimeException("符号表中无此键值");
        }
    }

    public void put(Integer key,T val){
        Node temp=head;
        while(temp.Next!=null&&temp.key!=key){
            temp=temp.Next;
        }
        if (temp.Next==null){
        temp.Next=new Node(key,val,null);}
        if(temp.key==key){
            temp.value=val;
        }
        N++;
    }

    public  void delete(Integer key){
        Node temp=head;
        while(temp.Next.key!=key){
            temp=temp.Next;
        }
        temp.Next=temp.Next.Next;
        N--;
    }

    public int size(){
        return N;
    }

    @Override
    public Iterator iterator() {
        return new Spliterator();
    }

    public class Spliterator implements Iterator{
        Node node =head;

        @Override
        public boolean hasNext() {
            return node.Next!=null;
        }

        @Override
        public Object next() {
            node=node.Next;
            return node.value;
        }
    }
}

//测试
package com.bit.list;

public class SymboltableTest {
    public static void main(String[] args) {
        Symboltable<String> Sym=new Symboltable<String>();

        Sym.put(1,"a");
        Sym.put(2,"b");
        Sym.put(3,"c");
        Sym.put(5,"d");
        Sym.put(1,"e");
        System.out.println(Sym.get(1));
        Sym.delete(1);
        for (Object t:Sym) {
            System.out.println(t);
        }
    }
}
```

#### 4.5.2 有序符号表的实现

键值按顺序进行插入

```java
package com.bit.list;

import java.util.Iterator;

public class OrdeSymboltable<Key extends Comparable,Value>extends Symboltable{
    private int N;
    private Node head;

    public OrdeSymboltable() {
        N = 0;
        this.head = new Node(null,null,null);

    }

    public class Node{

        private Key key;
        private Value value;
        public Node Next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.Next=next;

        }
    }


    public void put(Key key, Value val) {
        Node temp = head;

        while(temp.Next!=null&&key.compareTo(temp.Next.key)>0){
            temp=temp.Next;
        }
        if(temp.Next==null){
            temp.Next = new Node(key,val,null);

        }else if (key.compareTo(temp.Next.key)==0) {
            temp.Next.value=val;
            return;
        }else if(key.compareTo(temp.Next.key)<0) {
            Node node =new Node(key,val,temp.Next);
            temp.Next=node;
        }
        N++;
    }
    public  void delete(Integer key){
        Node temp=head;
        while(temp.Next.key!=key){
            temp=temp.Next;
        }
        temp.Next=temp.Next.Next;
        N--;
    }

    public int size(){
        return N;
    }


    public Iterator iterator() {
        return new Spliterator();
    }

    public class Spliterator implements Iterator{
        Node node =head;

        @Override
        public boolean hasNext() {
            return node.Next!=null;
        }

        @Override
        public Object next() {
            node=node.Next;
            return node.value;
        }
    }

}


//测试

package com.bit.list;

import javax.swing.*;

public class OrdeSymboltableTest {
    public static void main(String[] args) {
        OrdeSymboltable<Integer, String> Sym = new OrdeSymboltable<Integer, String>();
        Sym.put(1, "a");
        Sym.put(2, "b");
        Sym.put(3, "c");
        Sym.put(5, "d");
        Sym.put(4, "e");
        //System.out.println(Sym.get(1));
        System.out.println("||||||||||||||||||||||||||||||");
        for (Object t : Sym) {
            System.out.println(t);
        }
        Sym.delete(1);
        System.out.println("||||||||||||||||||||||||||||||");
        for (Object t : Sym) {
            System.out.println(t);
        }
    }
}
```

## 5 树

### 5.1 树的基本定义

树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。
树是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

**树具有以下特点：**
1.每个结点有零个或多个子结点；
2.没有父结点的结点为根结点；
3.每一个非根结点只有一个父结点；
4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；



### 5.2 树的相关术语

**结点的度**：
一个结点含有的子树的个数称为该结点的度；
**叶结点**：
度为0的结点称为叶结点，也可以叫做终端结点
**分支结点**：
度不为0的结点称为分支结点，也可以叫做非终端结点
**结点的层次**：
从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推
**结点的层序编号**：
将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数

**n个节点的二叉树一共有((2n)!)/(n!*(n+1)!)种**

**树的度**：
树中所有结点的度的最大值
**树的高度**(深度)：
树中结点的最大层次
**森林**：
m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树
**孩子结点**：
一个结点的**直接后继结点称为该结点的孩子结点**
**双亲结点**(父结点)：
一个结点的**直接前驱称为该结点的双亲结点**
**兄弟结点**：
同一双亲结点的孩子结点间互称兄弟结点

**补充：**

前驱结点：对一棵二叉树进行**中序遍历**，遍历后的顺序，当前结点的前一个结点为该结点的前驱结点；

后继结点：对一棵二叉树进行**中序遍历**，遍历后的顺序，当前结点的后一个结点为该结点的后继结点；

例如一颗完全二叉树（1,2,3,4,5,6,7），按照中序遍历后的顺序为：（4,2,5,1,6,3,7），1结点的前驱结点为：5，后继结点为6.

**前驱结点和后继结点的作用主要是用来方便树的删除操作**

### 5.3 **二叉树的基本定义**

二叉树就是度不超过2的树(每个结点最多有两个子结点)

**满二叉树：**一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。

**完全二叉树**：
叶结点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

#### 性质

如果该二叉树的左子树不为空，则**左子树上所有节点的值均小于它的根节点的值**； 若它的右子树不空，**则右子树上所有节点的值均大于它的根节点的值**；它的左右子树也为二叉搜索树。

**中序遍历 =正序**



### 5.4 二叉查找树

#### 5.4.1 创建插入获取

```java
package com.bit.tree;
import java.util.LinkedList;
import java.util.Queue;

class Tree<T extends Comparable,Value> {
    private Node head;

    public Tree() {
        this.head = null;
    }

    public class Node {

        private Node left;
        private Node right;
        private T key;
        private Value value;

    public Node(Value val, T key) {
        this.value = val;
        this.key = key;
    }
    }

    public void put(Value val,T key){
        this.head=this.put(head,val,key);
    }
    public Node put(Node node,Value val,T key){

        if (node== null) {
            node=new Node(val,key);
        } else if (key.compareTo(node.key)==0) {
            node.value=val;
        } else if (key.compareTo(node.key)<0){
            node.left=put(node.left,val,key);
        } else if (key.compareTo(node.key)>0){
            node.right=put(node.right,val,key);
        }
        return node;
    }


    public Value get(T key) {
        return get(head,key);
    }
    public Value get(Node node ,T key) {
        if (node == null) {
            return null;
        } else if (key.compareTo(node.key)==0) {
            return node.value;
        } else if (key.compareTo(node.key)<0){
            return get(node.left,key);
        } else if (key.compareTo(node.key)>0){
            return get(node.right,key);
        }
        return null;

    }

```

#### 5.4.2 删除

删除结点度为2的结点，做法是找到它的前驱结点，或者后继结点，例如上图，要删除的结点，按照二叉搜索树的规则，要找到一个结点代替要删除的结点的位置，使其程成为一个新的二叉搜索树，那么这个结点就是要删除的结点的**左子树结点的最大值，或者右子树的最小值，也就是器前驱结点，或者后继结点，**

```java
  public void delete(T key){
        head = delete(head,key);
    }

    public Node delete(Node node, T key) {
        //寻找要删除的键a
        if (node == null) {
            return null;
        }else if (key.compareTo(node.key)<0){
            node.left = delete(node.left,key);
            return node;
        } else if (key.compareTo(node.key)>0){
            node.right = delete(node.right,key);
            return node;
        }
     
        //找到键a后，查找键a的右键的 最左键 i 替换当前的键，并把查找到的i删除
        //如果键a的right = null；直接返回right即可
        if(node.right==null){
            return node.left;
        }
        //如果键a的left = null；直接返回left即可
        if(node.left==null){
            return node.right;
        }

        Node temp =node.right;
        if (temp.left==null) {// 若i的左键为null
            temp.left=node.left;
            return temp;
        } else {
            ////查找键a的右键的 最左键 i 替换当前的键，并把查找到的i删除

            while(temp.left.left!=null) {
                temp=temp.left;
            }
            Node ex_temp = temp.left; //查找到的i
            ex_temp.left = node.left;//替换
            ex_temp.right = node.right;
            temp.left=null;//把查找到的i删除

            return ex_temp;//return 时父结点连接到ex_temp;
        }

    }
```

#### 5.4.3 获取最大最小键值

```java

    public Value min(){
        return min(head);
    }
    public Value min(Node node){
        if(node.left!=null){
            return min(node.left);
        }
        return node.value;
    }

    public Value max(){
        return max(head);
    }
    public Value max(Node node){
        if(node.right!=null){
            return max(node.right);
        }
        return node.value;
    }

```

#### 5.4.4 遍历方法

```java
  
//深度优先搜索思想的遍历方法
public void preErgodic(){

        Queue<Value> list=new LinkedList<>();//必须要new一个否则会出现空指针异常
        list=preErgodic(head,list);
        for (Object i:list
             ) {
            System.out.println(i);
        }}
    public Queue<Value> preErgodic(Node node,Queue<Value> list) {

        if (node == null) {
            return null;
        }
        list.add(node.value);//根

            //向泛型中添加元素；
        if (node.left!=null){
            preErgodic(node.left,list);//左
        }
        if (node.right!=null){
            preErgodic(node.right,list);//右
        }
        return list;
    }
    public void midErgodic(){

        Queue<Value> list=new LinkedList<>();//必须要new一个否则会出现空指针异常
        list=midErgodic(head,list);
        for (Object i:list
        ) {
            System.out.println(i);
        }}
    public Queue<Value> midErgodic(Node node,Queue<Value> list) {

        if (node == null) {
            return null;
        }
        if (node.left!=null) {

            midErgodic(node.left,list);//左
        }
        //向泛型中添加元素；

        list.add(node.value);//根


        if (node.right!=null){
            midErgodic(node.right,list);//右
        }
        return list;

    }public void lastErgodic(){

        Queue<Value> list=new LinkedList<>();//必须要new一个否则会出现空指针异常
        list=lastErgodic(head,list);
        for (Object i:list
        ) {
            System.out.println(i);
        }}
    public Queue<Value> lastErgodic(Node node,Queue<Value> list) {

        if (node == null) {
            return null;
        }
        if (node.left!=null) {
            lastErgodic(node.left,list);//左
        }

        if (node.right!=null){
            lastErgodic(node.right,list);//右
        }
        //向泛型中添加元素；

        list.add(node.value);//根


        return list;
    }


    //层序遍历。利用队列实现,广度优先思想
    public Queue<Value> layerErgodic(){
        Queue<Value> q1 = new LinkedList();
        Queue<Node> nodes = new LinkedList();
        nodes.add(head);
        Node temp;
        while(nodes.size()!=0){
            temp = nodes.poll();
            q1.add(temp.value);
            if(temp.left!=null){
                 nodes.add(temp.left);
            }
            if(temp.right!=null){
                nodes.add(temp.right);
            }
        }
        for (Object i:q1
        ) {
            System.out.println(i);
        }
        return q1;
    }

```

#### 5.4.5树的最大深度

```java

 
    public int maxDepth() {
        return maxDepth(head);
    }
//计算指定树x的最大深度
    private int maxDepth(Node x) {
//1.如果根结点为空，则最大深度为0；
        if (x == null) {
            return 0;
        }
        int max = 0;
        int maxL = 0;
        int maxR = 0;
//2.计算左子树的最大深度；
        if (x.left != null) {
            maxL = maxDepth(x.left);
        }
//3.计算右子树的最大深度；
        if (x.right != null) {
            maxR = maxDepth(x.right);
        }
//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1
        max = maxL > maxR ? maxL + 1 : maxR + 1;
        return max;
    }

}

```

### 5.5 线索化二叉树

#### 5.5.1 定义

在传统二叉树的基础上，利用空的指针域，当一个结点的左孩子为空时，让其指向其前驱结点；当结点的右孩子为空时，让其指向后继结点。 那这个前驱和后继是通过什么来判断的呢？二叉树的遍历，前序、中序、后续遍历的顺序均可，但层次遍历的不行，原因在后面线索二叉树的遍历中说。
将原先的空指针利用起来后，会存在一个问题：我们怎么知道一个结点的孩子指向的是它真正的孩子还是老王的孩子？hhh，开个玩笑，我们需要知道指针域指向的是真正的孩子还是线索结点，那我们就需要左右两边都需要一个bool型的标志变量来标志。线索二叉树的结点的结构应为：

其中，ltag和rtag就是上述的标志变量。

#### 5.5.2 .创建

线索二叉树的创建必须是在树建立好以后才创建的，其创建的过程其实就是一个遍历二叉树的过程，在遍历的过程中需要使用一个全局变量每次将前驱结点记录下来。具体的创建过程和递归遍历的结果很类似；


### 5.6 折纸问题

需求：
请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，折
痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，上
到下依次是下折痕、下折痕和上折痕。给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：

N=1时，打印： down；N=2时，打印： down down up
分析：
我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的折
痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。
这棵树有这样的特点：
1.根结点为下折痕；
2.每一个结点的左子结点为下折痕；
3.每一个结点的右子结点为上折痕；
**实现步骤：**
1.定义结点类
2.构建深度为N的折痕树；
3.使用中序遍历，打印出树中所有结点的内容；
**构建深度为N的折痕树：**
1.第一次对折，只有一条折痕，创建根结点；
2.如果不是第一次对折，则使用队列保存根结点；
3.循环遍历队列：
3.1从队列中拿出一个结点；
3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；
3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；
3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。



## 6 堆

### 6.1 堆的定义

堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。

**堆的特性：**
1.它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的**，如果最后一层结点不**
**是满的，那么要求左满右不满。**

2.它通常用数组来实现。
具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。
如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。
这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2,向下一层就令k等于2k或2k+1。

3.每个结点都大于等于它的两个子结点。**这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点**，但这两个
子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。

### 6.2 堆的实现

```

```











# 算法思想

## 分治思想

### 设计要点  

1. 原问题可以划分或者归约为规模较小的子问题 
2. 子问题与原问题**具有相同的性质** 
3. 子问题的**求解彼此独立** 
4. 划分时子问题的规模尽可能均衡 
5. **子问题规模足够小时可直接求解** 
6.  子问题的解**综合**得到原问题的解 

### 算法实现

递归或迭代

### 时间复杂度分析

时间复杂度函数的递推方程 

```
W(n)=W(|P1 |)+W(|P2 |)+...+W(|Pk |)+f(n)  

W(c)=C 
```

• P1 , P2 , …, Pk 为 划分后产生的 子问题 

• f(n)为划分子问题以及将子问题的解 综合得到原问题解的总工作量 

• 规模为c的最小子问题的工作量为C

<img src="笔记图库/image-20210908104230596.png" alt="image-20210908104230596" style="zoom: 67%;" />

<img src="笔记图库/image-20210908104310145.png" alt="image-20210908104310145" style="zoom:67%;" />

<img src="C:\Users\songjiaqiang\AppData\Roaming\Typora\typora-user-images\image-20210908103848003.png" alt="image-20210908103848003" style="zoom: 67%;" />





## 动态规划

寻找子问题和父问题之间的关系；找出递推公式和设置初值

## 贪心算法

假设策略，反例验证，执行

哈夫曼算法：最优前缀码

## 回溯算法

如果当前结点不满足约束条件,能够推导出它的子结点也不满足约束条件,那么就可以放弃搜索它的子结点.其实这就是多米诺性质.



## 二分查找

```java
  public int Binary(int[] nums, int target ,int front, int end){
        if(target<nums[front]||target>nums[end]||front>end){
            return -1;
        }
        int mid = (front+end)>>1;
        if(nums[mid]>target){
            return Binary(nums,target,front,mid-1);//mid-1
        }else if(nums[mid]<target){
            return Binary(nums,target,mid+1,end);//mid+1
        }
        return mid;
    }
```

